// Copyright  Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"

	"go.opentelemetry.io/collector/component"
	"gopkg.in/yaml.v3"

	"github.com/signalfx/splunk-otel-collector/internal/receiver/discoveryreceiver"
)

type extensionMetadata struct {
	ExtensionID    component.ID `yaml:"extension_id"`
	PropertiesTmpl string       `yaml:"properties_tmpl"`
	FileName       string
}

type receiverMetadata struct {
	ReceiverID     component.ID `yaml:"receiver_id"`
	PropertiesTmpl string       `yaml:"properties_tmpl"`
	ServiceType    string       `yaml:"service_type"`
	FileName       string
	Status         discoveryreceiver.Status `yaml:"status"`
}

const (
	bundledHeader = `##############################################################################################
#                               Do not edit manually!                                        #
# All changes must be made to associated .yaml metadata file before running 'make bundle.d'. #
##############################################################################################
`

	commentedHeader = `#####################################################################################
# This file is generated by the Splunk Distribution of the OpenTelemetry Collector. #
#                                                                                   #
# It reflects the default configuration bundled in the Collector executable for use #
# in discovery mode (--discovery) and is provided for reference or customization.   #
# Please note that any changes made to this file will need to be reconciled during  #
# upgrades of the Collector.                                                        #
#####################################################################################
`
)

func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func loadExtensionMetadata(dir string) []extensionMetadata {
	var extensions []extensionMetadata
	files, err := filepath.Glob(filepath.Join(dir, "*.yaml"))
	panicOnError(err)
	for _, file := range files {
		data, err := os.ReadFile(file)
		panicOnError(err)
		var metadata extensionMetadata
		panicOnError(yaml.Unmarshal(data, &metadata))
		// Extract filename without extension
		metadata.FileName = strings.TrimSuffix(filepath.Base(file), ".yaml")
		extensions = append(extensions, metadata)
	}
	return extensions
}

func loadReceiverMetadata(dir string) []receiverMetadata {
	var receivers []receiverMetadata
	files, err := filepath.Glob(filepath.Join(dir, "*.yaml"))
	panicOnError(err)
	for _, file := range files {
		data, err := os.ReadFile(file)
		panicOnError(err)
		var metadata receiverMetadata
		panicOnError(yaml.Unmarshal(data, &metadata))
		// Extract filename without extension
		metadata.FileName = strings.TrimSuffix(filepath.Base(file), ".yaml")
		panicOnError(validateReceiverMetadata(metadata))
		receivers = append(receivers, metadata)
	}
	return receivers
}

func main() {
	_, thisFile, _, ok := runtime.Caller(0)
	if !ok {
		panic("failed to get current file path")
	}
	metadataDir := filepath.Join(filepath.Dir(thisFile), "metadata")
	projectRoot := filepath.Join(filepath.Dir(thisFile), "..", "..")
	bundleDir := filepath.Join(projectRoot, "internal", "confmapprovider", "discovery", "bundle.d")
	configDLinuxDir := filepath.Join(projectRoot, "cmd", "otelcol", "config", "collector", "config.d.linux")

	// Generate properties files for extensions
	extensions := loadExtensionMetadata(filepath.Join(metadataDir, "extensions"))
	for _, extension := range extensions {
		bundleFile := filepath.Join(filepath.Join(bundleDir, "extensions"), extension.FileName+".discovery.yaml")
		generateFile(extension.PropertiesTmpl, bundleFile, false, extension.ExtensionID)
		configDLinuxFile := filepath.Join(filepath.Join(configDLinuxDir, "extensions"), extension.FileName+".discovery.yaml")
		generateFile(extension.PropertiesTmpl, configDLinuxFile, true, extension.ExtensionID)
	}

	// Generate properties files for receivers
	receivers := loadReceiverMetadata(filepath.Join(metadataDir, "receivers"))
	for _, receiver := range receivers {
		bundleFile := filepath.Join(filepath.Join(bundleDir, "receivers"), receiver.FileName+".discovery.yaml")
		generateFile(receiver.PropertiesTmpl, bundleFile, false, receiver.ReceiverID)
		configDLinuxFile := filepath.Join(filepath.Join(configDLinuxDir, "receivers"), receiver.FileName+".discovery.yaml")
		generateFile(receiver.PropertiesTmpl, configDLinuxFile, true, receiver.ReceiverID)
	}

	bundleFSTemplate := filepath.Join(projectRoot, "internal", "confmapprovider", "discovery", "bundledfs.tmpl")
	genBundledFS(bundleFSTemplate, extensions, receivers)

	// Generate receiverMetaMap for discovery receiver
	discoveryReceiverDir := filepath.Join(projectRoot, "internal", "receiver", "discoveryreceiver")
	generateReceiverMetadataFile(discoveryReceiverDir, receivers)
}

func generateFile(propertiesTmpl, outFile string, commented bool, componentID component.ID) {
	t, err := template.New("discoverybundler").Funcs(funcMap(componentID)).Parse(propertiesTmpl)
	panicOnError(err)

	tempOut := &bytes.Buffer{}
	panicOnError(t.Execute(tempOut, nil))

	contentBuf := &bytes.Buffer{}
	contentBuf.WriteString(componentID.String())
	contentBuf.WriteString(":\n")
	contentBuf.WriteString(prependAllLines(tempOut.String(), "  "))

	body := contentBuf.String()
	out := &bytes.Buffer{}
	if commented {
		body = prependAllLines(contentBuf.String(), "# ")
		out.WriteString(commentedHeader)
	} else {
		out.WriteString(bundledHeader)
	}
	out.WriteString(body)

	var rendered map[string]any
	if err = yaml.Unmarshal(contentBuf.Bytes(), &rendered); err != nil {
		panicOnError(fmt.Errorf("failed unmarshaling component %s: %w", componentID, err))
	}

	if err = os.WriteFile(outFile, out.Bytes(), 0o600); err != nil {
		panicOnError(fmt.Errorf("failed writing to %s: %w", outFile, err))
	}
}

func prependAllLines(content, prefix string) string {
	prefixed := strings.ReplaceAll(content, "\n", "\n"+prefix)
	return prefix + strings.TrimSuffix(prefixed, prefix)
}

func genBundledFS(bundleFSFile string, extensions []extensionMetadata, receivers []receiverMetadata) {
	bundleFSTmpl, err := os.ReadFile(bundleFSFile)
	panicOnError(err)

	target := struct {
		ExtensionFiles []string
		ReceiverFiles  []string
	}{}
	for _, ext := range extensions {
		target.ExtensionFiles = append(target.ExtensionFiles, ext.FileName)
	}
	for _, rec := range receivers {
		target.ReceiverFiles = append(target.ReceiverFiles, rec.FileName)
	}

	t, err := template.New("bundledfs").Parse(string(bundleFSTmpl))
	panicOnError(err)
	out := &bytes.Buffer{}
	panicOnError(t.Execute(out, target))
	filename := filepath.Join(filepath.Dir(bundleFSFile), "generated_bundledfs.go")
	if err = os.WriteFile(filename, out.Bytes(), 0o644); err != nil { // nolint:gosec // existing project file permissions
		panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
	}
}

func generateReceiverMetadataFile(discoveryReceiverDir string, receivers []receiverMetadata) {
	templatePath := "templates/receiver_metadata.go.tmpl"
	templateData, err := os.ReadFile(templatePath)
	panicOnError(err)

	tmpl, err := template.New("receiver_metadata").Funcs(template.FuncMap{
		"formatMessage": formatMessage,
	}).Parse(string(templateData))
	panicOnError(err)
	out := &bytes.Buffer{}
	panicOnError(tmpl.Execute(out, map[string]any{
		"receivers": receivers,
	}))

	filename := filepath.Join(discoveryReceiverDir, "generated_metadata.go")
	if err := os.WriteFile(filename, out.Bytes(), 0o644); err != nil { // nolint:gosec // existing project file permissions
		panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
	}

	cmd := exec.Command("go", "fmt", filename) //nolint:gosec // the command is only for local usage, not shipped
	if err := cmd.Run(); err != nil {
		panicOnError(fmt.Errorf("failed formatting %s: %w", filename, err))
	}
}

// processMessageTemplate processes a message template with the given component ID.
func processMessageTemplate(message string, componentID component.ID) string {
	tmpl, err := template.New("message").Funcs(funcMap(componentID)).Parse(message)
	if err != nil {
		panic(fmt.Errorf("failed to parse message template: %w", err))
	}

	var buf bytes.Buffer
	panicOnError(tmpl.Execute(&buf, nil))
	return buf.String()
}

func formatMessage(message string, componentID component.ID) string {
	// Ensure the message is processed as a template first
	m := processMessageTemplate(message, componentID)
	// Replace newlines with Go string concatenation for readability
	return strings.ReplaceAll(fmt.Sprintf("%q", m), "\\n", `" +
				"`)
}

func validateReceiverMetadata(md receiverMetadata) error {
	if md.ReceiverID == (component.ID{}) {
		return fmt.Errorf("receiver ID cannot be empty")
	}
	if md.ServiceType == "" {
		return fmt.Errorf("service type cannot be empty for receiver %s", md.ReceiverID)
	}
	return md.Status.Validate()
}
