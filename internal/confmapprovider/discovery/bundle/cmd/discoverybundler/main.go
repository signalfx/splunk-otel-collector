// Copyright  Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"text/template"

	"gopkg.in/yaml.v3"
)

const (
	bundledHeader = `#####################################################################################
#                               Do not edit manually!                               #
# All changes must be made to associated .tmpl file before running 'make bundle.d'. #
#####################################################################################
`

	commentedHeader = `#####################################################################################
# This file is generated by the Splunk Distribution of the OpenTelemetry Collector. #
#                                                                                   #
# It reflects the default configuration bundled in the Collector executable for use #
# in discovery mode (--discovery) and is provided for reference or customization.   #
# Please note that any changes made to this file will need to be reconciled during  #
# upgrades of the Collector.                                                        #
#####################################################################################
`
)

func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	_, thisFile, _, ok := runtime.Caller(0)
	if !ok {
		panic("failed to get current file path")
	}
	bundleDir := filepath.Join(filepath.Dir(thisFile), "..", "..")
	projectRoot := filepath.Join(bundleDir, "..", "..", "..", "..")

	generateBundleFiles(filepath.Join(bundleDir, "bundle.d"))

	configDLinux := filepath.Join(projectRoot, "cmd", "otelcol", "config", "collector", "config.d.linux")
	generateConfigFiles(filepath.Join(bundleDir, "bundle.d"), configDLinux)

	genBundledFS(filepath.Join(bundleDir, "bundledfs.tmpl"))
}

func generateFile(templateFile string, outFile string, commented bool) {
	tmpl, err := os.ReadFile(templateFile)
	panicOnError(err)

	out := &bytes.Buffer{}
	if commented {
		out.WriteString(commentedHeader)
		tmpl = commentedTemplate(tmpl)
	} else {
		out.WriteString(bundledHeader)
	}

	t, err := template.New("discoverybundler").Funcs(FuncMap()).Parse(string(tmpl))
	panicOnError(err)

	panicOnError(t.Execute(out, nil))

	var rendered map[string]any
	// confirm rendered is valid yaml
	if err = yaml.Unmarshal(out.Bytes(), &rendered); err != nil {
		panicOnError(fmt.Errorf("failed unmarshaling %s: %w", templateFile, err))
	}

	if err = os.WriteFile(outFile, out.Bytes(), 0600); err != nil {
		panicOnError(fmt.Errorf("failed writing to %s: %w", outFile, err))
	}
}

// commentedTemplate will prepend "# " to all lines
// resulting in completely commented out file contents.
// The resulting template is still usable for execution
func commentedTemplate(tmpl []byte) []byte {
	tmplLen := len(tmpl)
	commented := []byte{'#', ' '}
	for i, b := range tmpl {
		commented = append(commented, b)
		if b == '\n' && i < tmplLen-1 {
			commented = append(commented, '#', ' ')
		}
	}
	return commented
}

// generateBundleFiles generates YAML files from .tmpl files in bundle.d
func generateBundleFiles(bundleDir string) {
	for _, extension := range Components.Extensions {
		templateFile := filepath.Join(bundleDir, "extensions", extension+".discovery.yaml.tmpl")
		outFile := filepath.Join(bundleDir, "extensions", extension+".discovery.yaml")
		generateFile(templateFile, outFile, false)
	}
	for _, receiver := range Components.Receivers {
		templateFile := filepath.Join(bundleDir, "receivers", receiver+".discovery.yaml.tmpl")
		outFile := filepath.Join(bundleDir, "receivers", receiver+".discovery.yaml")
		generateFile(templateFile, outFile, false)
	}
}

// generateConfigFiles generates commented YAML files for config.d.linux
func generateConfigFiles(bundleDir, configDir string) {
	extensionDir := filepath.Join(configDir, "extensions")
	for _, extension := range Components.Extensions {
		templateFile := filepath.Join(bundleDir, "extensions", extension+".discovery.yaml.tmpl")
		outFile := filepath.Join(extensionDir, extension+".discovery.yaml")
		generateFile(templateFile, outFile, true)
	}
	receiverDir := filepath.Join(configDir, "receivers")
	for _, receiver := range Components.Receivers {
		templateFile := filepath.Join(bundleDir, "receivers", receiver+".discovery.yaml.tmpl")
		outFile := filepath.Join(receiverDir, receiver+".discovery.yaml")
		generateFile(templateFile, outFile, true)
	}
}

func genBundledFS(bundleFSFile string) {
	bundleFSTmpl, err := os.ReadFile(bundleFSFile)
	panicOnError(err)

	for _, tup := range []struct {
		components map[string]struct{}
		tag        string
		suffix     string
	}{
		{tag: "windows", suffix: "windows", components: Components.Windows},
		{tag: "!windows", suffix: "others", components: Components.Linux},
	} {
		t, err := template.New(fmt.Sprintf("bundledfs_%s", tup.suffix)).Funcs(map[string]any{
			"tag":      func() string { return tup.tag },
			"included": func(s string) bool { _, ok := tup.components[s]; return ok },
		}).Parse(string(bundleFSTmpl))
		panicOnError(err)

		out := &bytes.Buffer{}
		panicOnError(t.Execute(out, Components))

		filename := filepath.Join("..", "..", fmt.Sprintf("bundledfs_%s.go", tup.suffix))
		if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil { // nolint:gosec // existing project file permissions
			panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
		}
	}
}
