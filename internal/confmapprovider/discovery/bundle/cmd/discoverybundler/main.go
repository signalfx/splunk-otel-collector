// Copyright  Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	flag "github.com/spf13/pflag"
	"gopkg.in/yaml.v3"

	"github.com/signalfx/splunk-otel-collector/internal/confmapprovider/discovery/bundle"
)

const (
	genHeader = `#####################################################################################
# This file is generated by the Splunk Distribution of the OpenTelemetry Collector. #
#####################################################################################
`
)

type settings struct {
	templateFile      string
	renderInParentDir bool
}

func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func loadSettings() *settings {
	s := &settings{}
	flagSet := flag.NewFlagSet("discoverybundler", flag.ContinueOnError)
	flagSet.StringVarP(&s.templateFile, "template", "t", "", "the discovery config template (.tmpl) to render")
	flagSet.BoolVarP(&s.renderInParentDir, "render", "r", false, `whether to render in parent dir (sans ".tmpl")`)
	panicOnError(flagSet.Parse(os.Args[1:]))
	return s
}

func main() {
	s := loadSettings()
	if s.templateFile == "" {
		panic("empty templateFile")
	}
	if !strings.HasSuffix(s.templateFile, ".tmpl") {
		panic(fmt.Errorf(`%q must end in ".tmpl"`, s.templateFile))
	}
	tmpl, err := os.ReadFile(s.templateFile)
	panicOnError(err)
	t, err := template.New("discoverybundler").Funcs(bundle.FuncMap()).Parse(string(tmpl))
	panicOnError(err)

	out := &bytes.Buffer{}
	out.WriteString(genHeader)
	panicOnError(t.Execute(out, nil))

	var rendered map[string]any
	// confirm rendered is valid yaml
	panicOnError(yaml.Unmarshal(out.Bytes(), &rendered))

	outFilename := strings.TrimSuffix(s.templateFile, ".tmpl")
	if s.renderInParentDir {
		panicOnError(os.WriteFile(outFilename, out.Bytes(), 0600))
	} else {
		fmt.Fprint(os.Stdout, out.String())
	}
}
