// Copyright  Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"

	"go.opentelemetry.io/collector/component"
	"gopkg.in/yaml.v3"
)

type ComponentMetadata struct {
	ComponentID    component.ID `yaml:"component_id"`
	PropertiesTmpl string       `yaml:"properties_tmpl"`
	FileName       string
}

const (
	bundledHeader = `##############################################################################################
#                               Do not edit manually!                                        #
# All changes must be made to associated .yaml metadata file before running 'make bundle.d'. #
##############################################################################################
`

	commentedHeader = `#####################################################################################
# This file is generated by the Splunk Distribution of the OpenTelemetry Collector. #
#                                                                                   #
# It reflects the default configuration bundled in the Collector executable for use #
# in discovery mode (--discovery) and is provided for reference or customization.   #
# Please note that any changes made to this file will need to be reconciled during  #
# upgrades of the Collector.                                                        #
#####################################################################################
`
)

func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func loadComponentMetadata(dir string) []ComponentMetadata {
	var components []ComponentMetadata
	files, err := filepath.Glob(filepath.Join(dir, "*.yaml"))
	panicOnError(err)
	for _, file := range files {
		data, err := os.ReadFile(file)
		panicOnError(err)
		var metadata ComponentMetadata
		panicOnError(yaml.Unmarshal(data, &metadata))
		// Extract filename without extension
		metadata.FileName = strings.TrimSuffix(filepath.Base(file), ".yaml")
		components = append(components, metadata)
	}
	return components
}

func main() {
	_, thisFile, _, ok := runtime.Caller(0)
	if !ok {
		panic("failed to get current file path")
	}
	metadataDir := filepath.Join(filepath.Dir(thisFile), "metadata")
	bundleDir := filepath.Join(filepath.Join(filepath.Dir(thisFile), "..", ".."), "bundle.d")
	projectRoot := filepath.Join(filepath.Dir(thisFile), "..", "..", "..", "..", "..", "..")
	configDLinuxDir := filepath.Join(projectRoot, "cmd", "otelcol", "config", "collector", "config.d.linux")

	// Generate properties files for extensions
	extensions := loadComponentMetadata(filepath.Join(metadataDir, "extensions"))
	for _, extension := range extensions {
		bundleFile := filepath.Join(filepath.Join(bundleDir, "extensions"), extension.FileName+".discovery.yaml")
		generateFile(extension.PropertiesTmpl, bundleFile, false, extension.ComponentID)
		configDLinuxFile := filepath.Join(filepath.Join(configDLinuxDir, "extensions"), extension.FileName+".discovery.yaml")
		generateFile(extension.PropertiesTmpl, configDLinuxFile, true, extension.ComponentID)
	}

	// Generate properties files for receivers
	receivers := loadComponentMetadata(filepath.Join(metadataDir, "receivers"))
	for _, receiver := range receivers {
		bundleFile := filepath.Join(filepath.Join(bundleDir, "receivers"), receiver.FileName+".discovery.yaml")
		generateFile(receiver.PropertiesTmpl, bundleFile, false, receiver.ComponentID)
		configDLinuxFile := filepath.Join(filepath.Join(configDLinuxDir, "receivers"), receiver.FileName+".discovery.yaml")
		generateFile(receiver.PropertiesTmpl, configDLinuxFile, true, receiver.ComponentID)
	}

	genBundledFS(filepath.Join(filepath.Join(bundleDir, ".."), "bundledfs.tmpl"), extensions, receivers)
}

func generateFile(propertiesTmpl string, outFile string, commented bool, componentID component.ID) {
	t, err := template.New("discoverybundler").Funcs(funcMap(componentID)).Parse(propertiesTmpl)
	panicOnError(err)

	tempOut := &bytes.Buffer{}
	panicOnError(t.Execute(tempOut, nil))

	contentBuf := &bytes.Buffer{}
	contentBuf.WriteString(componentID.String())
	contentBuf.WriteString(":\n")
	contentBuf.WriteString(prependAllLines(tempOut.String(), "  "))

	body := contentBuf.String()
	out := &bytes.Buffer{}
	if commented {
		body = prependAllLines(contentBuf.String(), "# ")
		out.WriteString(commentedHeader)
	} else {
		out.WriteString(bundledHeader)
	}
	out.WriteString(body)

	var rendered map[string]any
	if err = yaml.Unmarshal(contentBuf.Bytes(), &rendered); err != nil {
		panicOnError(fmt.Errorf("failed unmarshaling component %s: %w", componentID, err))
	}

	if err = os.WriteFile(outFile, out.Bytes(), 0600); err != nil {
		panicOnError(fmt.Errorf("failed writing to %s: %w", outFile, err))
	}
}

func prependAllLines(content, prefix string) string {
	prefixed := strings.ReplaceAll(content, "\n", "\n"+prefix)
	return prefix + strings.TrimSuffix(prefixed, prefix)
}

func genBundledFS(bundleFSFile string, extensions, receivers []ComponentMetadata) {
	bundleFSTmpl, err := os.ReadFile(bundleFSFile)
	panicOnError(err)

	target := struct {
		ExtensionFiles []string
		ReceiverFiles  []string
	}{}
	for _, ext := range extensions {
		target.ExtensionFiles = append(target.ExtensionFiles, ext.FileName)
	}
	for _, rec := range receivers {
		target.ReceiverFiles = append(target.ReceiverFiles, rec.FileName)
	}

	t, err := template.New("bundledfs").Parse(string(bundleFSTmpl))
	panicOnError(err)
	out := &bytes.Buffer{}
	panicOnError(t.Execute(out, target))
	filename := filepath.Join(filepath.Dir(bundleFSFile), "generated_bundledfs.go")
	if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil { // nolint:gosec // existing project file permissions
		panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
	}
}
