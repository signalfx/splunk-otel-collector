// Copyright  Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	flag "github.com/spf13/pflag"
	"gopkg.in/yaml.v3"

	"github.com/signalfx/splunk-otel-collector/internal/confmapprovider/discovery/bundle"
)

const (
	bundledHeader = `#####################################################################################
#                               Do not edit manually!                               #
# All changes must be made to associated .tmpl file before running 'make bundle.d'. #
#####################################################################################
`

	commentedHeader = `#####################################################################################
# This file is generated by the Splunk Distribution of the OpenTelemetry Collector. #
#                                                                                   #
# It reflects the default configuration bundled in the Collector executable for use #
# in discovery mode (--discovery) and is provided for reference or customization.   #
# Please note that any changes made to this file will need to be reconciled during  #
# upgrades of the Collector.                                                        #
#####################################################################################
`
)

type settings struct {
	templateFile string
	dir          string
	render       bool
	commented    bool
	bootstrap    bool
}

func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func loadSettings() *settings {
	s := &settings{}
	flagSet := flag.NewFlagSet("discoverybundler", flag.ContinueOnError)
	flagSet.StringVarP(&s.templateFile, "template", "t", "", "the discovery config template (.tmpl) to render")
	flagSet.BoolVarP(&s.render, "render", "r", false, `whether to render in parent dir (default) or to --dir`)
	flagSet.BoolVarP(&s.bootstrap, "bootstrap", "b", false, `run the bootstrap`)
	flagSet.StringVarP(&s.dir, "dir", "d", "", `target directory to render to (sans ".tmpl")`)
	flagSet.BoolVarP(&s.commented, "commented", "c", false, `whether to comment out all lines`)
	panicOnError(flagSet.Parse(os.Args[1:]))
	return s
}

func main() {
	s := loadSettings()
	if s.bootstrap {
		bootstrap()
		return
	}

	if s.templateFile == "" {
		panic("empty templateFile")
	}
	if !strings.HasSuffix(s.templateFile, ".tmpl") {
		panic(fmt.Errorf(`%q must end in ".tmpl"`, s.templateFile))
	}
	tmpl, err := os.ReadFile(s.templateFile)
	panicOnError(err)

	out := &bytes.Buffer{}
	if s.commented {
		out.WriteString(commentedHeader)
		tmpl = commentedTemplate(tmpl)
	} else {
		out.WriteString(bundledHeader)
	}

	t, err := template.New("discoverybundler").Funcs(bundle.FuncMap()).Parse(string(tmpl))
	panicOnError(err)

	panicOnError(t.Execute(out, nil))

	var rendered map[string]any
	// confirm rendered is valid yaml
	if err = yaml.Unmarshal(out.Bytes(), &rendered); err != nil {
		panicOnError(fmt.Errorf("failed unmarshaling %s: %w", s.templateFile, err))
	}

	outFilename := strings.TrimSuffix(s.templateFile, ".tmpl")
	if s.render {
		if s.dir != "" {
			filename := filepath.Base(outFilename)
			var absPath string
			if absPath, err = filepath.Abs(s.dir); err != nil {
				panicOnError(fmt.Errorf("failed determining target directory: %w", err))
			}
			outFilename = filepath.Join(absPath, filename)
		}
		if err = os.WriteFile(outFilename, out.Bytes(), 0600); err != nil {
			panicOnError(fmt.Errorf("failed writing to %s: %w", outFilename, err))
		}
	} else {
		fmt.Fprint(os.Stdout, out.String())
	}
}

// commentedTemplate will prepend "# " to all lines
// resulting in completely commented out file contents.
// The resulting template is still usable for execution
func commentedTemplate(tmpl []byte) []byte {
	tmplLen := len(tmpl)
	commented := []byte{'#', ' '}
	for i, b := range tmpl {
		commented = append(commented, b)
		if b == '\n' && i < tmplLen-1 {
			commented = append(commented, '#', ' ')
		}
	}
	return commented
}

// bootstrap will generate the bundle_gen.go file that invokes this lib, as
// well as the bundledfs.go files for default discovery mode content.
func bootstrap() {
	bundleGenTmpl, err := os.ReadFile(filepath.Join("..", "..", "bundle_gen.tmpl"))
	panicOnError(err)

	t, err := template.New("bundle_gen").Parse(string(bundleGenTmpl))
	panicOnError(err)

	out := &bytes.Buffer{}
	panicOnError(t.Execute(out, bundle.Components))

	filename := filepath.Join("..", "..", "bundle_gen.go")
	if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil { // nolint:gosec // existing project file permissions
		panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
	}

	genBundledFS()
}

func genBundledFS() {
	bundleFSTmpl, err := os.ReadFile(filepath.Join("..", "..", "bundledfs.tmpl"))
	panicOnError(err)

	for _, tup := range []struct {
		components map[string]struct{}
		tag        string
		suffix     string
	}{
		{tag: "windows", suffix: "windows", components: bundle.Components.Windows},
		{tag: "!windows", suffix: "others", components: bundle.Components.Linux},
	} {
		t, err := template.New(fmt.Sprintf("bundledfs_%s", tup.suffix)).Funcs(map[string]any{
			"tag":      func() string { return tup.tag },
			"included": func(s string) bool { _, ok := tup.components[s]; return ok },
		}).Parse(string(bundleFSTmpl))
		panicOnError(err)

		out := &bytes.Buffer{}
		panicOnError(t.Execute(out, bundle.Components))

		filename := filepath.Join("..", "..", fmt.Sprintf("bundledfs_%s.go", tup.suffix))
		if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil { // nolint:gosec // existing project file permissions
			panicOnError(fmt.Errorf("failed writing to %s: %w", filename, err))
		}
	}
}
