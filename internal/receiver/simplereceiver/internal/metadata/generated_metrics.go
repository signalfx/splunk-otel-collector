// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for githubmetricsreceiver metrics.
type MetricsSettings struct {
	CodechangesAdditions MetricSettings `mapstructure:"codechanges.additions"`
	CodechangesDeletions MetricSettings `mapstructure:"codechanges.deletions"`
	CommitsFriday        MetricSettings `mapstructure:"commits.friday"`
	CommitsMonday        MetricSettings `mapstructure:"commits.monday"`
	CommitsSaturday      MetricSettings `mapstructure:"commits.saturday"`
	CommitsSunday        MetricSettings `mapstructure:"commits.sunday"`
	CommitsThursday      MetricSettings `mapstructure:"commits.thursday"`
	CommitsTotalWeekly   MetricSettings `mapstructure:"commits.total.weekly"`
	CommitsTotalYtd      MetricSettings `mapstructure:"commits.total.ytd"`
	CommitsTuesday       MetricSettings `mapstructure:"commits.tuesday"`
	CommitsWednesday     MetricSettings `mapstructure:"commits.wednesday"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		CodechangesAdditions: MetricSettings{
			Enabled: true,
		},
		CodechangesDeletions: MetricSettings{
			Enabled: true,
		},
		CommitsFriday: MetricSettings{
			Enabled: true,
		},
		CommitsMonday: MetricSettings{
			Enabled: true,
		},
		CommitsSaturday: MetricSettings{
			Enabled: true,
		},
		CommitsSunday: MetricSettings{
			Enabled: true,
		},
		CommitsThursday: MetricSettings{
			Enabled: true,
		},
		CommitsTotalWeekly: MetricSettings{
			Enabled: true,
		},
		CommitsTotalYtd: MetricSettings{
			Enabled: true,
		},
		CommitsTuesday: MetricSettings{
			Enabled: true,
		},
		CommitsWednesday: MetricSettings{
			Enabled: true,
		},
	}
}

type metricCodechangesAdditions struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills codechanges.additions metric with initial data.
func (m *metricCodechangesAdditions) init() {
	m.data.SetName("codechanges.additions")
	m.data.SetDescription("Code additions to repo")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCodechangesAdditions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCodechangesAdditions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCodechangesAdditions) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCodechangesAdditions(settings MetricSettings) metricCodechangesAdditions {
	m := metricCodechangesAdditions{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCodechangesDeletions struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills codechanges.deletions metric with initial data.
func (m *metricCodechangesDeletions) init() {
	m.data.SetName("codechanges.deletions")
	m.data.SetDescription("Code deletions to repo")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCodechangesDeletions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCodechangesDeletions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCodechangesDeletions) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCodechangesDeletions(settings MetricSettings) metricCodechangesDeletions {
	m := metricCodechangesDeletions{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsFriday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.friday metric with initial data.
func (m *metricCommitsFriday) init() {
	m.data.SetName("commits.friday")
	m.data.SetDescription("Number of commits on Friday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsFriday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsFriday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsFriday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsFriday(settings MetricSettings) metricCommitsFriday {
	m := metricCommitsFriday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsMonday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.monday metric with initial data.
func (m *metricCommitsMonday) init() {
	m.data.SetName("commits.monday")
	m.data.SetDescription("Number of commits on Monday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsMonday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsMonday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsMonday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsMonday(settings MetricSettings) metricCommitsMonday {
	m := metricCommitsMonday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsSaturday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.saturday metric with initial data.
func (m *metricCommitsSaturday) init() {
	m.data.SetName("commits.saturday")
	m.data.SetDescription("Number of commits on Saturday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsSaturday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsSaturday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsSaturday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsSaturday(settings MetricSettings) metricCommitsSaturday {
	m := metricCommitsSaturday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsSunday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.sunday metric with initial data.
func (m *metricCommitsSunday) init() {
	m.data.SetName("commits.sunday")
	m.data.SetDescription("Number of commits on Sunday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsSunday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsSunday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsSunday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsSunday(settings MetricSettings) metricCommitsSunday {
	m := metricCommitsSunday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsThursday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.thursday metric with initial data.
func (m *metricCommitsThursday) init() {
	m.data.SetName("commits.thursday")
	m.data.SetDescription("Number of commits on Thursday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsThursday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsThursday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsThursday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsThursday(settings MetricSettings) metricCommitsThursday {
	m := metricCommitsThursday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsTotalWeekly struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.total.weekly metric with initial data.
func (m *metricCommitsTotalWeekly) init() {
	m.data.SetName("commits.total.weekly")
	m.data.SetDescription("Number of total commits this week (beginning Sunday)")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsTotalWeekly) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsTotalWeekly) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsTotalWeekly) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsTotalWeekly(settings MetricSettings) metricCommitsTotalWeekly {
	m := metricCommitsTotalWeekly{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsTotalYtd struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.total.ytd metric with initial data.
func (m *metricCommitsTotalYtd) init() {
	m.data.SetName("commits.total.ytd")
	m.data.SetDescription("Number of total commits YTD")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsTotalYtd) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsTotalYtd) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsTotalYtd) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsTotalYtd(settings MetricSettings) metricCommitsTotalYtd {
	m := metricCommitsTotalYtd{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsTuesday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.tuesday metric with initial data.
func (m *metricCommitsTuesday) init() {
	m.data.SetName("commits.tuesday")
	m.data.SetDescription("Number of commits on Tuesday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsTuesday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsTuesday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsTuesday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsTuesday(settings MetricSettings) metricCommitsTuesday {
	m := metricCommitsTuesday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCommitsWednesday struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills commits.wednesday metric with initial data.
func (m *metricCommitsWednesday) init() {
	m.data.SetName("commits.wednesday")
	m.data.SetDescription("Number of commits on Wednesday")
	m.data.SetUnit("1")
	m.data.SetDataType(pmetric.MetricDataTypeGauge)
}

func (m *metricCommitsWednesday) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCommitsWednesday) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCommitsWednesday) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCommitsWednesday(settings MetricSettings) metricCommitsWednesday {
	m := metricCommitsWednesday{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                  pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity            int                 // maximum observed number of metrics per resource.
	resourceCapacity           int                 // maximum observed number of resource attributes.
	metricsBuffer              pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                  component.BuildInfo // contains version information
	metricCodechangesAdditions metricCodechangesAdditions
	metricCodechangesDeletions metricCodechangesDeletions
	metricCommitsFriday        metricCommitsFriday
	metricCommitsMonday        metricCommitsMonday
	metricCommitsSaturday      metricCommitsSaturday
	metricCommitsSunday        metricCommitsSunday
	metricCommitsThursday      metricCommitsThursday
	metricCommitsTotalWeekly   metricCommitsTotalWeekly
	metricCommitsTotalYtd      metricCommitsTotalYtd
	metricCommitsTuesday       metricCommitsTuesday
	metricCommitsWednesday     metricCommitsWednesday
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                  pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:              pmetric.NewMetrics(),
		buildInfo:                  buildInfo,
		metricCodechangesAdditions: newMetricCodechangesAdditions(settings.CodechangesAdditions),
		metricCodechangesDeletions: newMetricCodechangesDeletions(settings.CodechangesDeletions),
		metricCommitsFriday:        newMetricCommitsFriday(settings.CommitsFriday),
		metricCommitsMonday:        newMetricCommitsMonday(settings.CommitsMonday),
		metricCommitsSaturday:      newMetricCommitsSaturday(settings.CommitsSaturday),
		metricCommitsSunday:        newMetricCommitsSunday(settings.CommitsSunday),
		metricCommitsThursday:      newMetricCommitsThursday(settings.CommitsThursday),
		metricCommitsTotalWeekly:   newMetricCommitsTotalWeekly(settings.CommitsTotalWeekly),
		metricCommitsTotalYtd:      newMetricCommitsTotalYtd(settings.CommitsTotalYtd),
		metricCommitsTuesday:       newMetricCommitsTuesday(settings.CommitsTuesday),
		metricCommitsWednesday:     newMetricCommitsWednesday(settings.CommitsWednesday),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithGithubRepoName sets provided value as "github.repo.name" attribute for current resource.
func WithGithubRepoName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertString("github.repo.name", val)
	}
}

// WithGithubRepoUsername sets provided value as "github.repo.username" attribute for current resource.
func WithGithubRepoUsername(val) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().UpsertEmpty("github.repo.username", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).DataType() {
			case pmetric.MetricDataTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricDataTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/githubmetricsreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricCodechangesAdditions.emit(ils.Metrics())
	mb.metricCodechangesDeletions.emit(ils.Metrics())
	mb.metricCommitsFriday.emit(ils.Metrics())
	mb.metricCommitsMonday.emit(ils.Metrics())
	mb.metricCommitsSaturday.emit(ils.Metrics())
	mb.metricCommitsSunday.emit(ils.Metrics())
	mb.metricCommitsThursday.emit(ils.Metrics())
	mb.metricCommitsTotalWeekly.emit(ils.Metrics())
	mb.metricCommitsTotalYtd.emit(ils.Metrics())
	mb.metricCommitsTuesday.emit(ils.Metrics())
	mb.metricCommitsWednesday.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordCodechangesAdditionsDataPoint adds a data point to codechanges.additions metric.
func (mb *MetricsBuilder) RecordCodechangesAdditionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCodechangesAdditions.recordDataPoint(mb.startTime, ts, val)
}

// RecordCodechangesDeletionsDataPoint adds a data point to codechanges.deletions metric.
func (mb *MetricsBuilder) RecordCodechangesDeletionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCodechangesDeletions.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsFridayDataPoint adds a data point to commits.friday metric.
func (mb *MetricsBuilder) RecordCommitsFridayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsFriday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsMondayDataPoint adds a data point to commits.monday metric.
func (mb *MetricsBuilder) RecordCommitsMondayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsMonday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsSaturdayDataPoint adds a data point to commits.saturday metric.
func (mb *MetricsBuilder) RecordCommitsSaturdayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsSaturday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsSundayDataPoint adds a data point to commits.sunday metric.
func (mb *MetricsBuilder) RecordCommitsSundayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsSunday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsThursdayDataPoint adds a data point to commits.thursday metric.
func (mb *MetricsBuilder) RecordCommitsThursdayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsThursday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsTotalWeeklyDataPoint adds a data point to commits.total.weekly metric.
func (mb *MetricsBuilder) RecordCommitsTotalWeeklyDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsTotalWeekly.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsTotalYtdDataPoint adds a data point to commits.total.ytd metric.
func (mb *MetricsBuilder) RecordCommitsTotalYtdDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsTotalYtd.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsTuesdayDataPoint adds a data point to commits.tuesday metric.
func (mb *MetricsBuilder) RecordCommitsTuesdayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsTuesday.recordDataPoint(mb.startTime, ts, val)
}

// RecordCommitsWednesdayDataPoint adds a data point to commits.wednesday metric.
func (mb *MetricsBuilder) RecordCommitsWednesdayDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricCommitsWednesday.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
