// Code generated by monitor-code-gen. DO NOT EDIT.

package kafkaproducer

import (
	"github.com/signalfx/golib/v3/datapoint"
	"github.com/signalfx/signalfx-agent/pkg/monitors"
)

const monitorType = "collectd/kafka_producer"

const (
	groupJvm = "jvm"
)

var groupSet = map[string]bool{
	groupJvm: true,
}

const (
	gaugeJvmThreadsCount                = "gauge.jvm.threads.count"
	gaugeKafkaProducerByteRate          = "gauge.kafka.producer.byte-rate"
	gaugeKafkaProducerCompressionRate   = "gauge.kafka.producer.compression-rate"
	gaugeKafkaProducerIoWaitTimeNsAvg   = "gauge.kafka.producer.io-wait-time-ns-avg"
	gaugeKafkaProducerOutgoingByteRate  = "gauge.kafka.producer.outgoing-byte-rate"
	gaugeKafkaProducerRecordErrorRate   = "gauge.kafka.producer.record-error-rate"
	gaugeKafkaProducerRecordRetryRate   = "gauge.kafka.producer.record-retry-rate"
	gaugeKafkaProducerRecordSendRate    = "gauge.kafka.producer.record-send-rate"
	gaugeKafkaProducerRequestLatencyAvg = "gauge.kafka.producer.request-latency-avg"
	gaugeKafkaProducerRequestRate       = "gauge.kafka.producer.request-rate"
	gaugeKafkaProducerResponseRate      = "gauge.kafka.producer.response-rate"
	gaugeLoadedClasses                  = "gauge.loaded_classes"
	invocations                         = "invocations"
	jmxMemoryCommitted                  = "jmx_memory.committed"
	jmxMemoryInit                       = "jmx_memory.init"
	jmxMemoryMax                        = "jmx_memory.max"
	jmxMemoryUsed                       = "jmx_memory.used"
	totalTimeInMsCollectionTime         = "total_time_in_ms.collection_time"
)

var metricSet = map[string]monitors.MetricInfo{
	gaugeJvmThreadsCount:                {Type: datapoint.Gauge, Group: groupJvm},
	gaugeKafkaProducerByteRate:          {Type: datapoint.Gauge},
	gaugeKafkaProducerCompressionRate:   {Type: datapoint.Gauge},
	gaugeKafkaProducerIoWaitTimeNsAvg:   {Type: datapoint.Gauge},
	gaugeKafkaProducerOutgoingByteRate:  {Type: datapoint.Gauge},
	gaugeKafkaProducerRecordErrorRate:   {Type: datapoint.Gauge},
	gaugeKafkaProducerRecordRetryRate:   {Type: datapoint.Gauge},
	gaugeKafkaProducerRecordSendRate:    {Type: datapoint.Gauge},
	gaugeKafkaProducerRequestLatencyAvg: {Type: datapoint.Gauge},
	gaugeKafkaProducerRequestRate:       {Type: datapoint.Gauge},
	gaugeKafkaProducerResponseRate:      {Type: datapoint.Gauge},
	gaugeLoadedClasses:                  {Type: datapoint.Gauge, Group: groupJvm},
	invocations:                         {Type: datapoint.Counter, Group: groupJvm},
	jmxMemoryCommitted:                  {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryInit:                       {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryMax:                        {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryUsed:                       {Type: datapoint.Gauge, Group: groupJvm},
	totalTimeInMsCollectionTime:         {Type: datapoint.Counter, Group: groupJvm},
}

var defaultMetrics = map[string]bool{
	gaugeJvmThreadsCount:                true,
	gaugeKafkaProducerByteRate:          true,
	gaugeKafkaProducerCompressionRate:   true,
	gaugeKafkaProducerIoWaitTimeNsAvg:   true,
	gaugeKafkaProducerOutgoingByteRate:  true,
	gaugeKafkaProducerRecordErrorRate:   true,
	gaugeKafkaProducerRecordRetryRate:   true,
	gaugeKafkaProducerRecordSendRate:    true,
	gaugeKafkaProducerRequestLatencyAvg: true,
	gaugeKafkaProducerRequestRate:       true,
	gaugeKafkaProducerResponseRate:      true,
	gaugeLoadedClasses:                  true,
	invocations:                         true,
	jmxMemoryCommitted:                  true,
	jmxMemoryInit:                       true,
	jmxMemoryMax:                        true,
	jmxMemoryUsed:                       true,
	totalTimeInMsCollectionTime:         true,
}

var groupMetricsMap = map[string][]string{
	groupJvm: {
		gaugeJvmThreadsCount,
		gaugeLoadedClasses,
		invocations,
		jmxMemoryCommitted,
		jmxMemoryInit,
		jmxMemoryMax,
		jmxMemoryUsed,
		totalTimeInMsCollectionTime,
	},
}

var monitorMetadata = monitors.Metadata{
	MonitorType:     "collectd/kafka_producer",
	DefaultMetrics:  defaultMetrics,
	Metrics:         metricSet,
	SendUnknown:     true,
	Groups:          groupSet,
	GroupMetricsMap: groupMetricsMap,
	SendAll:         false,
}
