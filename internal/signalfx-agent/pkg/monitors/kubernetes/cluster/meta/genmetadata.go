// Code generated by monitor-code-gen. DO NOT EDIT.

package meta

import (
	"github.com/signalfx/golib/v3/datapoint"
	"github.com/signalfx/signalfx-agent/pkg/monitors"
)

const (
	GroupHpa = "hpa"
)

var GroupSet = map[string]bool{
	GroupHpa: true,
}

const (
	KubernetesContainerCPULimit                            = "kubernetes.container_cpu_limit"
	KubernetesContainerCPURequest                          = "kubernetes.container_cpu_request"
	KubernetesContainerEphemeralStorageLimit               = "kubernetes.container_ephemeral_storage_limit"
	KubernetesContainerEphemeralStorageRequest             = "kubernetes.container_ephemeral_storage_request"
	KubernetesContainerMemoryLimit                         = "kubernetes.container_memory_limit"
	KubernetesContainerMemoryRequest                       = "kubernetes.container_memory_request"
	KubernetesContainerReady                               = "kubernetes.container_ready"
	KubernetesContainerRestartCount                        = "kubernetes.container_restart_count"
	KubernetesCronjobActive                                = "kubernetes.cronjob.active"
	KubernetesDaemonSetCurrentScheduled                    = "kubernetes.daemon_set.current_scheduled"
	KubernetesDaemonSetDesiredScheduled                    = "kubernetes.daemon_set.desired_scheduled"
	KubernetesDaemonSetMisscheduled                        = "kubernetes.daemon_set.misscheduled"
	KubernetesDaemonSetReady                               = "kubernetes.daemon_set.ready"
	KubernetesDaemonSetUpdated                             = "kubernetes.daemon_set.updated"
	KubernetesDeploymentAvailable                          = "kubernetes.deployment.available"
	KubernetesDeploymentDesired                            = "kubernetes.deployment.desired"
	KubernetesDeploymentUpdated                            = "kubernetes.deployment.updated"
	KubernetesHpaSpecMaxReplicas                           = "kubernetes.hpa.spec.max_replicas"
	KubernetesHpaSpecMinReplicas                           = "kubernetes.hpa.spec.min_replicas"
	KubernetesHpaStatusConditionAbleToScale                = "kubernetes.hpa.status.condition.able_to_scale"
	KubernetesHpaStatusConditionScalingActive              = "kubernetes.hpa.status.condition.scaling_active"
	KubernetesHpaStatusConditionScalingLimited             = "kubernetes.hpa.status.condition.scaling_limited"
	KubernetesHpaStatusCurrentReplicas                     = "kubernetes.hpa.status.current_replicas"
	KubernetesHpaStatusDesiredReplicas                     = "kubernetes.hpa.status.desired_replicas"
	KubernetesJobActive                                    = "kubernetes.job.active"
	KubernetesJobCompletions                               = "kubernetes.job.completions"
	KubernetesJobFailed                                    = "kubernetes.job.failed"
	KubernetesJobParallelism                               = "kubernetes.job.parallelism"
	KubernetesJobSucceeded                                 = "kubernetes.job.succeeded"
	KubernetesNamespacePhase                               = "kubernetes.namespace_phase"
	KubernetesNodeAllocatableCPU                           = "kubernetes.node_allocatable_cpu"
	KubernetesNodeAllocatableEphemeralStorage              = "kubernetes.node_allocatable_ephemeral_storage"
	KubernetesNodeAllocatableMemory                        = "kubernetes.node_allocatable_memory"
	KubernetesNodeAllocatableStorage                       = "kubernetes.node_allocatable_storage"
	KubernetesNodeReady                                    = "kubernetes.node_ready"
	KubernetesPodPhase                                     = "kubernetes.pod_phase"
	KubernetesReplicaSetAvailable                          = "kubernetes.replica_set.available"
	KubernetesReplicaSetDesired                            = "kubernetes.replica_set.desired"
	KubernetesReplicationControllerAvailable               = "kubernetes.replication_controller.available"
	KubernetesReplicationControllerDesired                 = "kubernetes.replication_controller.desired"
	KubernetesResourceQuotaHard                            = "kubernetes.resource_quota_hard"
	KubernetesResourceQuotaUsed                            = "kubernetes.resource_quota_used"
	KubernetesStatefulSetCurrent                           = "kubernetes.stateful_set.current"
	KubernetesStatefulSetDesired                           = "kubernetes.stateful_set.desired"
	KubernetesStatefulSetReady                             = "kubernetes.stateful_set.ready"
	KubernetesStatefulSetUpdated                           = "kubernetes.stateful_set.updated"
	OpenshiftAppliedclusterquotaCPUHard                    = "openshift.appliedclusterquota.cpu.hard"
	OpenshiftAppliedclusterquotaCPUUsed                    = "openshift.appliedclusterquota.cpu.used"
	OpenshiftAppliedclusterquotaMemoryHard                 = "openshift.appliedclusterquota.memory.hard"
	OpenshiftAppliedclusterquotaMemoryUsed                 = "openshift.appliedclusterquota.memory.used"
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsHard = "openshift.appliedclusterquota.persistentvolumeclaims.hard"
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsUsed = "openshift.appliedclusterquota.persistentvolumeclaims.used"
	OpenshiftAppliedclusterquotaPodsHard                   = "openshift.appliedclusterquota.pods.hard"
	OpenshiftAppliedclusterquotaPodsUsed                   = "openshift.appliedclusterquota.pods.used"
	OpenshiftAppliedclusterquotaServicesHard               = "openshift.appliedclusterquota.services.hard"
	OpenshiftAppliedclusterquotaServicesLoadbalancersHard  = "openshift.appliedclusterquota.services.loadbalancers.hard"
	OpenshiftAppliedclusterquotaServicesLoadbalancersUsed  = "openshift.appliedclusterquota.services.loadbalancers.used"
	OpenshiftAppliedclusterquotaServicesNodeportsHard      = "openshift.appliedclusterquota.services.nodeports.hard"
	OpenshiftAppliedclusterquotaServicesNodeportsUsed      = "openshift.appliedclusterquota.services.nodeports.used"
	OpenshiftAppliedclusterquotaServicesUsed               = "openshift.appliedclusterquota.services.used"
	OpenshiftClusterquotaCPUHard                           = "openshift.clusterquota.cpu.hard"
	OpenshiftClusterquotaCPUUsed                           = "openshift.clusterquota.cpu.used"
	OpenshiftClusterquotaMemoryHard                        = "openshift.clusterquota.memory.hard"
	OpenshiftClusterquotaMemoryUsed                        = "openshift.clusterquota.memory.used"
	OpenshiftClusterquotaPersistentvolumeclaimsHard        = "openshift.clusterquota.persistentvolumeclaims.hard"
	OpenshiftClusterquotaPersistentvolumeclaimsUsed        = "openshift.clusterquota.persistentvolumeclaims.used"
	OpenshiftClusterquotaPodsHard                          = "openshift.clusterquota.pods.hard"
	OpenshiftClusterquotaPodsUsed                          = "openshift.clusterquota.pods.used"
	OpenshiftClusterquotaServicesHard                      = "openshift.clusterquota.services.hard"
	OpenshiftClusterquotaServicesLoadbalancersHard         = "openshift.clusterquota.services.loadbalancers.hard"
	OpenshiftClusterquotaServicesLoadbalancersUsed         = "openshift.clusterquota.services.loadbalancers.used"
	OpenshiftClusterquotaServicesNodeportsHard             = "openshift.clusterquota.services.nodeports.hard"
	OpenshiftClusterquotaServicesNodeportsUsed             = "openshift.clusterquota.services.nodeports.used"
	OpenshiftClusterquotaServicesUsed                      = "openshift.clusterquota.services.used"
)

var MetricSet = map[string]monitors.MetricInfo{
	KubernetesContainerCPULimit:                            {Type: datapoint.Gauge},
	KubernetesContainerCPURequest:                          {Type: datapoint.Gauge},
	KubernetesContainerEphemeralStorageLimit:               {Type: datapoint.Gauge},
	KubernetesContainerEphemeralStorageRequest:             {Type: datapoint.Gauge},
	KubernetesContainerMemoryLimit:                         {Type: datapoint.Gauge},
	KubernetesContainerMemoryRequest:                       {Type: datapoint.Gauge},
	KubernetesContainerReady:                               {Type: datapoint.Gauge},
	KubernetesContainerRestartCount:                        {Type: datapoint.Gauge},
	KubernetesCronjobActive:                                {Type: datapoint.Gauge},
	KubernetesDaemonSetCurrentScheduled:                    {Type: datapoint.Gauge},
	KubernetesDaemonSetDesiredScheduled:                    {Type: datapoint.Gauge},
	KubernetesDaemonSetMisscheduled:                        {Type: datapoint.Gauge},
	KubernetesDaemonSetReady:                               {Type: datapoint.Gauge},
	KubernetesDaemonSetUpdated:                             {Type: datapoint.Gauge},
	KubernetesDeploymentAvailable:                          {Type: datapoint.Gauge},
	KubernetesDeploymentDesired:                            {Type: datapoint.Gauge},
	KubernetesDeploymentUpdated:                            {Type: datapoint.Gauge},
	KubernetesHpaSpecMaxReplicas:                           {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaSpecMinReplicas:                           {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaStatusConditionAbleToScale:                {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaStatusConditionScalingActive:              {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaStatusConditionScalingLimited:             {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaStatusCurrentReplicas:                     {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesHpaStatusDesiredReplicas:                     {Type: datapoint.Gauge, Group: GroupHpa},
	KubernetesJobActive:                                    {Type: datapoint.Gauge},
	KubernetesJobCompletions:                               {Type: datapoint.Gauge},
	KubernetesJobFailed:                                    {Type: datapoint.Counter},
	KubernetesJobParallelism:                               {Type: datapoint.Gauge},
	KubernetesJobSucceeded:                                 {Type: datapoint.Counter},
	KubernetesNamespacePhase:                               {Type: datapoint.Gauge},
	KubernetesNodeAllocatableCPU:                           {Type: datapoint.Gauge},
	KubernetesNodeAllocatableEphemeralStorage:              {Type: datapoint.Gauge},
	KubernetesNodeAllocatableMemory:                        {Type: datapoint.Gauge},
	KubernetesNodeAllocatableStorage:                       {Type: datapoint.Gauge},
	KubernetesNodeReady:                                    {Type: datapoint.Gauge},
	KubernetesPodPhase:                                     {Type: datapoint.Gauge},
	KubernetesReplicaSetAvailable:                          {Type: datapoint.Gauge},
	KubernetesReplicaSetDesired:                            {Type: datapoint.Gauge},
	KubernetesReplicationControllerAvailable:               {Type: datapoint.Gauge},
	KubernetesReplicationControllerDesired:                 {Type: datapoint.Gauge},
	KubernetesResourceQuotaHard:                            {Type: datapoint.Gauge},
	KubernetesResourceQuotaUsed:                            {Type: datapoint.Gauge},
	KubernetesStatefulSetCurrent:                           {Type: datapoint.Gauge},
	KubernetesStatefulSetDesired:                           {Type: datapoint.Gauge},
	KubernetesStatefulSetReady:                             {Type: datapoint.Gauge},
	KubernetesStatefulSetUpdated:                           {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaCPUHard:                    {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaCPUUsed:                    {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaMemoryHard:                 {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaMemoryUsed:                 {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsHard: {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsUsed: {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaPodsHard:                   {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaPodsUsed:                   {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesHard:               {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesLoadbalancersHard:  {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesLoadbalancersUsed:  {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesNodeportsHard:      {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesNodeportsUsed:      {Type: datapoint.Gauge},
	OpenshiftAppliedclusterquotaServicesUsed:               {Type: datapoint.Gauge},
	OpenshiftClusterquotaCPUHard:                           {Type: datapoint.Gauge},
	OpenshiftClusterquotaCPUUsed:                           {Type: datapoint.Gauge},
	OpenshiftClusterquotaMemoryHard:                        {Type: datapoint.Gauge},
	OpenshiftClusterquotaMemoryUsed:                        {Type: datapoint.Gauge},
	OpenshiftClusterquotaPersistentvolumeclaimsHard:        {Type: datapoint.Gauge},
	OpenshiftClusterquotaPersistentvolumeclaimsUsed:        {Type: datapoint.Gauge},
	OpenshiftClusterquotaPodsHard:                          {Type: datapoint.Gauge},
	OpenshiftClusterquotaPodsUsed:                          {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesHard:                      {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesLoadbalancersHard:         {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesLoadbalancersUsed:         {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesNodeportsHard:             {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesNodeportsUsed:             {Type: datapoint.Gauge},
	OpenshiftClusterquotaServicesUsed:                      {Type: datapoint.Gauge},
}

var DefaultMetrics = map[string]bool{
	KubernetesContainerCPULimit:                            true,
	KubernetesContainerMemoryLimit:                         true,
	KubernetesContainerReady:                               true,
	KubernetesContainerRestartCount:                        true,
	KubernetesDaemonSetCurrentScheduled:                    true,
	KubernetesDaemonSetDesiredScheduled:                    true,
	KubernetesDaemonSetMisscheduled:                        true,
	KubernetesDaemonSetReady:                               true,
	KubernetesDeploymentAvailable:                          true,
	KubernetesDeploymentDesired:                            true,
	KubernetesNamespacePhase:                               true,
	KubernetesNodeReady:                                    true,
	KubernetesPodPhase:                                     true,
	KubernetesReplicaSetAvailable:                          true,
	KubernetesReplicaSetDesired:                            true,
	KubernetesReplicationControllerAvailable:               true,
	KubernetesReplicationControllerDesired:                 true,
	KubernetesResourceQuotaHard:                            true,
	KubernetesResourceQuotaUsed:                            true,
	OpenshiftAppliedclusterquotaCPUHard:                    true,
	OpenshiftAppliedclusterquotaCPUUsed:                    true,
	OpenshiftAppliedclusterquotaMemoryHard:                 true,
	OpenshiftAppliedclusterquotaMemoryUsed:                 true,
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsHard: true,
	OpenshiftAppliedclusterquotaPersistentvolumeclaimsUsed: true,
	OpenshiftAppliedclusterquotaPodsHard:                   true,
	OpenshiftAppliedclusterquotaPodsUsed:                   true,
	OpenshiftAppliedclusterquotaServicesHard:               true,
	OpenshiftAppliedclusterquotaServicesLoadbalancersHard:  true,
	OpenshiftAppliedclusterquotaServicesLoadbalancersUsed:  true,
	OpenshiftAppliedclusterquotaServicesNodeportsHard:      true,
	OpenshiftAppliedclusterquotaServicesNodeportsUsed:      true,
	OpenshiftAppliedclusterquotaServicesUsed:               true,
	OpenshiftClusterquotaCPUHard:                           true,
	OpenshiftClusterquotaCPUUsed:                           true,
	OpenshiftClusterquotaMemoryHard:                        true,
	OpenshiftClusterquotaMemoryUsed:                        true,
	OpenshiftClusterquotaPersistentvolumeclaimsHard:        true,
	OpenshiftClusterquotaPersistentvolumeclaimsUsed:        true,
	OpenshiftClusterquotaPodsHard:                          true,
	OpenshiftClusterquotaPodsUsed:                          true,
	OpenshiftClusterquotaServicesHard:                      true,
	OpenshiftClusterquotaServicesLoadbalancersHard:         true,
	OpenshiftClusterquotaServicesLoadbalancersUsed:         true,
	OpenshiftClusterquotaServicesNodeportsHard:             true,
	OpenshiftClusterquotaServicesNodeportsUsed:             true,
	OpenshiftClusterquotaServicesUsed:                      true,
}

var GroupMetricsMap = map[string][]string{
	GroupHpa: {
		KubernetesHpaSpecMaxReplicas,
		KubernetesHpaSpecMaxReplicas,
		KubernetesHpaSpecMinReplicas,
		KubernetesHpaSpecMinReplicas,
		KubernetesHpaStatusConditionAbleToScale,
		KubernetesHpaStatusConditionAbleToScale,
		KubernetesHpaStatusConditionScalingActive,
		KubernetesHpaStatusConditionScalingActive,
		KubernetesHpaStatusConditionScalingLimited,
		KubernetesHpaStatusConditionScalingLimited,
		KubernetesHpaStatusCurrentReplicas,
		KubernetesHpaStatusCurrentReplicas,
		KubernetesHpaStatusDesiredReplicas,
		KubernetesHpaStatusDesiredReplicas,
	},
}

var KubernetesClusterMonitorMetadata = monitors.Metadata{
	MonitorType:     "kubernetes-cluster",
	DefaultMetrics:  DefaultMetrics,
	Metrics:         MetricSet,
	SendUnknown:     true,
	Groups:          GroupSet,
	GroupMetricsMap: GroupMetricsMap,
	SendAll:         false,
}

var OpenshiftClusterMonitorMetadata = monitors.Metadata{
	MonitorType:     "openshift-cluster",
	DefaultMetrics:  DefaultMetrics,
	Metrics:         MetricSet,
	SendUnknown:     true,
	Groups:          GroupSet,
	GroupMetricsMap: GroupMetricsMap,
	SendAll:         false,
}
