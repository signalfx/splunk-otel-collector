// Copyright Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/splunk/splunk-technical-addon/internal/modularinput"
)

const generatedFileName = "modinput_config.go"

const configTemplate = `// Code generated by modinput_config_generator; DO NOT EDIT.
package main

import (
	"github.com/splunk/splunk-technical-addon/internal/modularinput"
)

const SchemaName = "{{ $.SchemaName }}";

type {{ toPascal .SchemaName }}ModInput struct {
	Value string
	Name string
}

type {{ toPascal .SchemaName }}ModularInputs struct {
	{{- range $name, $inputConfig := .ModularInputs }}
	{{ toPascal $name }} {{ toPascal $.SchemaName }}ModInput
	{{- end }}
}

func Get{{ toPascal .SchemaName }}ModularInputs(mip *modularinput.ModinputProcessor) *{{ toPascal .SchemaName }}ModularInputs {
	return &{{ toPascal .SchemaName }}ModularInputs{
		{{- range $name, $inputConfig := .ModularInputs }}
		{{ toPascal $name }}: {{ toPascal $.SchemaName }}ModInput{
			Value: mip.ModularInputs["{{ $name }}"].Value,
			Name: "{{ $name }}",
		},
		{{- end }}
	}
}

// GetDefault{{ toPascal .SchemaName }}ModularInputs returns the embedded modular input configuration
func GetDefault{{ toPascal .SchemaName }}ModularInputs() modularinput.GenericModularInput {
	return modularinput.GenericModularInput{
		SchemaName: "{{ $.SchemaName}}",
		ModularInputs: map[string]*modularinput.ModInput{
			{{- range $name, $inputConfig := .ModularInputs }}
			"{{ $name }}": &modularinput.ModInput{
				Config: {{ printf "%#v" $inputConfig }},
				{{- if $inputConfig.Default }}
				Value: "{{ $inputConfig.Default }}",
				{{- end }}
				Transformers: []modularinput.TransformerFunc{
					{{- if $inputConfig.ReplaceableEnvVar }}
					modularinput.DefaultReplaceEnvVarTransformer,
					{{- end }}
				},
			},
			{{- end }}
		},
	}
}
`

// Given a yaml file specifying the modular inputs, generates a new golang file (see: generatedFileName) in same directory as yaml file based
func generateModinputConfig(config *modularinput.TemplateData, outDir string) error {
	outputPath := filepath.Join(outDir, generatedFileName)

	tmpl, err := template.New("config").Funcs(template.FuncMap{
		"toPascal": SnakeToPascal, // snake_case to PascalCase
	}).Parse(configTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	if err = tmpl.Execute(outputFile, config); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	log.Printf("Generated code: %s\n", outputPath)
	return nil
}

// Given a yaml file specifying the modular inputs, renders all templates (.tmpl) under assets directory to same relative
// file tree in addon
func generateTaModInputConfs(config *modularinput.TemplateData, addonSourceDir, buildDir string) error {
	assetsDir := filepath.Join(addonSourceDir, "assets")
	templateSuffix := ".tmpl"
	outDir := filepath.Join(buildDir, config.SchemaName)
	err := os.MkdirAll(outDir, 0o755)
	if err != nil {
		return fmt.Errorf("failed create output dir %s: %w", outDir, err)
	}
	err = os.CopyFS(outDir, os.DirFS(assetsDir))
	if err != nil {
		return fmt.Errorf("failed to copy from %s to %s: %w", assetsDir, outDir, err)
	}
	err = filepath.WalkDir(outDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(d.Name(), templateSuffix) {
			// Render new file to same path, chopping off the .tmpl suffix
			relPath, err := filepath.Rel(outDir, path)
			if err != nil {
				return err
			}
			outputPath := filepath.Join(outDir, filepath.Dir(relPath), d.Name()[:len(d.Name())-len(templateSuffix)])
			if err = modularinput.RenderTemplate(path, outputPath, config); err != nil {
				return fmt.Errorf("could not render template: %w", err)
			}
			log.Printf("Generated template: %s\n", outputPath)
			err = os.Remove(path)
			if err != nil {
				return err
			}
			log.Printf("Removed template: %s\n", path)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to render contents from %s to %s: %w", assetsDir, outDir, err)
	}

	return nil
}

func SnakeToPascal(snake string) string {
	words := strings.Split(snake, "_")
	var sb strings.Builder

	for _, word := range words {
		if word == "" {
			continue
		}
		sb.WriteRune(unicode.ToUpper(rune(word[0])))
		sb.WriteString(word[1:])
	}

	return sb.String()
}

func loadYaml(yamlPath, schemaName string) (*modularinput.TemplateData, error) {
	if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
		log.Fatalf("YAML file not found: %s", yamlPath)
	}
	config, err := modularinput.LoadConfig(yamlPath)
	if err != nil {
		return nil, err
	}
	if !strings.EqualFold(config.SchemaName, schemaName) {
		return nil, fmt.Errorf("schema name mismatch: expected %q, got %q in file %s",
			schemaName, config.SchemaName, yamlPath)
	}
	return config, nil
}
