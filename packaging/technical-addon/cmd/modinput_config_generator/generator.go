// Copyright Splunk, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/splunk/splunk-technical-addon/internal/modularinput"
)

const generatedFileName = "modinput_config.go"

const configTemplate = `// Code generated by runner_config_generator; DO NOT EDIT.
package main

import (
	"github.com/splunk/splunk-technical-addon/internal/modularinput"
)

type {{ toPascal .SchemaName }}ModularInput struct {
	SchemaName 		string
	ModularInputs 	map[string]modularinput.ModInput
}

// GetDefault{{ toPascal .SchemaName }}ModularInputs returns the embedded modular input configuration
func GetDefault{{ toPascal .SchemaName }}ModularInputs() {{ toPascal .SchemaName }}ModularInput {
	return {{ toPascal .SchemaName }}ModularInput{
		SchemaName: "{{ $.SchemaName}}",
		ModularInputs: map[string]modularinput.ModInput{
			{{- range $name, $inputConfig := .ModularInputs }}
			"{{ $name }}": modularinput.ModInput{
				Config: {{ printf "%#v" $inputConfig }},
				{{- if $inputConfig.Default }}
				Value: "{{ $inputConfig.Default }}",
				{{- end }}
				Transformers: []modularinput.TransformerFunc{
					{{- if $inputConfig.ReplaceableEnvVar }}
					modularinput.DefaultReplaceEnvVarTransformer,
					{{- end }}
				},
			},
			{{- end }}
		},
	}
}
`

// Given a yaml file specifying the modular inputs, generates a new golang file (see: generatedFileName) in same directory as yaml file based
func generateModinputConfig(config *modularinput.TemplateData, outDir string) error {

	outputPath := filepath.Join(outDir, generatedFileName)

	tmpl, err := template.New("config").Funcs(template.FuncMap{
		"toPascal": SnakeToPascal, // snake_case to PascalCase
	}).Parse(configTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, config); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	log.Printf("Generated code: %s\n", outputPath)
	return nil
}

// Given a yaml file specifying the modular inputs and a .tmpl file, generates a new inputs.conf.spec file and inputs.conf file
func generateTaModInputConfs(config *modularinput.TemplateData, addonSourceDir string, outDir string) error {
	// handle README/inputs.conf.spec
	specTemplatePath := filepath.Join(addonSourceDir, "assets", "inputs.conf.spec.tmpl")
	if _, err := os.Stat(specTemplatePath); os.IsNotExist(err) {
		return fmt.Errorf("template file not found: %s", specTemplatePath)
	}
	specOutputDir := filepath.Join(outDir, "README")
	if err := os.MkdirAll(specOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	specOutputPath := filepath.Join(specOutputDir, "inputs.conf.spec")
	if err := modularinput.RenderTemplate(specTemplatePath, specOutputPath, config); err != nil {
		return err
	}
	log.Printf("Generated: %s\n", specOutputPath)

	// Handle default/inputs.conf
	defaultConfTemplatePath := filepath.Join(addonSourceDir, "assets", "inputs.conf.tmpl")
	if _, err := os.Stat(defaultConfTemplatePath); os.IsNotExist(err) {
		return fmt.Errorf("template file not found: %s", defaultConfTemplatePath)
	}
	defaultConfOutputDir := filepath.Join(outDir, "default")
	if err := os.MkdirAll(defaultConfOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	defaultConfOutputPath := filepath.Join(defaultConfOutputDir, "inputs.conf")
	if err := modularinput.RenderTemplate(defaultConfTemplatePath, defaultConfOutputPath, config); err != nil {
		return err
	}
	log.Printf("Generated: %s\n", defaultConfOutputPath)

	return nil
}

func SnakeToPascal(snake string) string {
	words := strings.Split(snake, "_")
	var sb strings.Builder

	for _, word := range words {
		if word == "" {
			continue
		}
		sb.WriteRune(unicode.ToUpper(rune(word[0])))
		sb.WriteString(word[1:])
	}

	return sb.String()
}

func loadYaml(yamlPath string, schemaName string) (*modularinput.TemplateData, error) {
	if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
		log.Fatalf("YAML file not found: %s", yamlPath)
	}
	config, err := modularinput.LoadConfig(yamlPath)
	if err != nil {
		return nil, err
	}
	if !strings.EqualFold(config.SchemaName, schemaName) {
		return nil, fmt.Errorf("schema name mismatch: expected %q, got %q in file %s",
			schemaName, config.SchemaName, yamlPath)
	}
	return config, nil
}
