// Code generated by monitor-code-gen. DO NOT EDIT.

package kafka

import (
	"github.com/signalfx/golib/v3/datapoint"
	"github.com/signalfx/signalfx-agent/pkg/monitors"
)

const monitorType = "collectd/kafka"

const (
	groupJvm = "jvm"
)

var groupSet = map[string]bool{
	groupJvm: true,
}

const (
	counterKafkaBytesIn                     = "counter.kafka-bytes-in"
	counterKafkaBytesOut                    = "counter.kafka-bytes-out"
	counterKafkaIsrExpands                  = "counter.kafka-isr-expands"
	counterKafkaIsrShrinks                  = "counter.kafka-isr-shrinks"
	counterKafkaLeaderElectionRate          = "counter.kafka-leader-election-rate"
	counterKafkaMessagesIn                  = "counter.kafka-messages-in"
	counterKafkaUncleanElectionsRate        = "counter.kafka-unclean-elections-rate"
	counterKafkaFetchConsumerTotalTimeCount = "counter.kafka.fetch-consumer.total-time.count"
	counterKafkaFetchFollowerTotalTimeCount = "counter.kafka.fetch-follower.total-time.count"
	counterKafkaLogsFlushTimeCount          = "counter.kafka.logs.flush-time.count"
	counterKafkaProduceTotalTimeCount       = "counter.kafka.produce.total-time.count"
	gaugeJvmThreadsCount                    = "gauge.jvm.threads.count"
	gaugeKafkaActiveControllers             = "gauge.kafka-active-controllers"
	gaugeKafkaMaxLag                        = "gauge.kafka-max-lag"
	gaugeKafkaOfflinePartitionsCount        = "gauge.kafka-offline-partitions-count"
	gaugeKafkaRequestQueue                  = "gauge.kafka-request-queue"
	gaugeKafkaUnderreplicatedPartitions     = "gauge.kafka-underreplicated-partitions"
	gaugeKafkaFetchConsumerTotalTime99th    = "gauge.kafka.fetch-consumer.total-time.99th"
	gaugeKafkaFetchConsumerTotalTimeMedian  = "gauge.kafka.fetch-consumer.total-time.median"
	gaugeKafkaFetchFollowerTotalTime99th    = "gauge.kafka.fetch-follower.total-time.99th"
	gaugeKafkaFetchFollowerTotalTimeMedian  = "gauge.kafka.fetch-follower.total-time.median"
	gaugeKafkaLogsFlushTime99th             = "gauge.kafka.logs.flush-time.99th"
	gaugeKafkaLogsFlushTimeMedian           = "gauge.kafka.logs.flush-time.median"
	gaugeKafkaProduceTotalTime99th          = "gauge.kafka.produce.total-time.99th"
	gaugeKafkaProduceTotalTimeMedian        = "gauge.kafka.produce.total-time.median"
	gaugeLoadedClasses                      = "gauge.loaded_classes"
	invocations                             = "invocations"
	jmxMemoryCommitted                      = "jmx_memory.committed"
	jmxMemoryInit                           = "jmx_memory.init"
	jmxMemoryMax                            = "jmx_memory.max"
	jmxMemoryUsed                           = "jmx_memory.used"
	totalTimeInMsCollectionTime             = "total_time_in_ms.collection_time"
)

var metricSet = map[string]monitors.MetricInfo{
	counterKafkaBytesIn:                     {Type: datapoint.Counter},
	counterKafkaBytesOut:                    {Type: datapoint.Counter},
	counterKafkaIsrExpands:                  {Type: datapoint.Counter},
	counterKafkaIsrShrinks:                  {Type: datapoint.Counter},
	counterKafkaLeaderElectionRate:          {Type: datapoint.Counter},
	counterKafkaMessagesIn:                  {Type: datapoint.Counter},
	counterKafkaUncleanElectionsRate:        {Type: datapoint.Counter},
	counterKafkaFetchConsumerTotalTimeCount: {Type: datapoint.Counter},
	counterKafkaFetchFollowerTotalTimeCount: {Type: datapoint.Counter},
	counterKafkaLogsFlushTimeCount:          {Type: datapoint.Counter},
	counterKafkaProduceTotalTimeCount:       {Type: datapoint.Counter},
	gaugeJvmThreadsCount:                    {Type: datapoint.Gauge, Group: groupJvm},
	gaugeKafkaActiveControllers:             {Type: datapoint.Gauge},
	gaugeKafkaMaxLag:                        {Type: datapoint.Gauge},
	gaugeKafkaOfflinePartitionsCount:        {Type: datapoint.Gauge},
	gaugeKafkaRequestQueue:                  {Type: datapoint.Gauge},
	gaugeKafkaUnderreplicatedPartitions:     {Type: datapoint.Gauge},
	gaugeKafkaFetchConsumerTotalTime99th:    {Type: datapoint.Gauge},
	gaugeKafkaFetchConsumerTotalTimeMedian:  {Type: datapoint.Gauge},
	gaugeKafkaFetchFollowerTotalTime99th:    {Type: datapoint.Gauge},
	gaugeKafkaFetchFollowerTotalTimeMedian:  {Type: datapoint.Gauge},
	gaugeKafkaLogsFlushTime99th:             {Type: datapoint.Gauge},
	gaugeKafkaLogsFlushTimeMedian:           {Type: datapoint.Gauge},
	gaugeKafkaProduceTotalTime99th:          {Type: datapoint.Gauge},
	gaugeKafkaProduceTotalTimeMedian:        {Type: datapoint.Gauge},
	gaugeLoadedClasses:                      {Type: datapoint.Gauge, Group: groupJvm},
	invocations:                             {Type: datapoint.Counter, Group: groupJvm},
	jmxMemoryCommitted:                      {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryInit:                           {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryMax:                            {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryUsed:                           {Type: datapoint.Gauge, Group: groupJvm},
	totalTimeInMsCollectionTime:             {Type: datapoint.Counter, Group: groupJvm},
}

var defaultMetrics = map[string]bool{
	counterKafkaBytesIn:                     true,
	counterKafkaBytesOut:                    true,
	counterKafkaIsrExpands:                  true,
	counterKafkaIsrShrinks:                  true,
	counterKafkaMessagesIn:                  true,
	counterKafkaUncleanElectionsRate:        true,
	counterKafkaFetchConsumerTotalTimeCount: true,
	counterKafkaProduceTotalTimeCount:       true,
	gaugeJvmThreadsCount:                    true,
	gaugeKafkaActiveControllers:             true,
	gaugeKafkaMaxLag:                        true,
	gaugeKafkaOfflinePartitionsCount:        true,
	gaugeKafkaRequestQueue:                  true,
	gaugeKafkaUnderreplicatedPartitions:     true,
	gaugeKafkaFetchConsumerTotalTime99th:    true,
	gaugeKafkaFetchConsumerTotalTimeMedian:  true,
	gaugeKafkaFetchFollowerTotalTime99th:    true,
	gaugeKafkaFetchFollowerTotalTimeMedian:  true,
	gaugeKafkaProduceTotalTime99th:          true,
	gaugeKafkaProduceTotalTimeMedian:        true,
	gaugeLoadedClasses:                      true,
	invocations:                             true,
	jmxMemoryCommitted:                      true,
	jmxMemoryInit:                           true,
	jmxMemoryMax:                            true,
	jmxMemoryUsed:                           true,
	totalTimeInMsCollectionTime:             true,
}

var groupMetricsMap = map[string][]string{
	groupJvm: []string{
		gaugeJvmThreadsCount,
		gaugeLoadedClasses,
		invocations,
		jmxMemoryCommitted,
		jmxMemoryInit,
		jmxMemoryMax,
		jmxMemoryUsed,
		totalTimeInMsCollectionTime,
	},
}

var monitorMetadata = monitors.Metadata{
	MonitorType:     "collectd/kafka",
	DefaultMetrics:  defaultMetrics,
	Metrics:         metricSet,
	SendUnknown:     true,
	Groups:          groupSet,
	GroupMetricsMap: groupMetricsMap,
	SendAll:         false,
}
