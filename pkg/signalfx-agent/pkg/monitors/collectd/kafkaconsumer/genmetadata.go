// Code generated by monitor-code-gen. DO NOT EDIT.

package kafkaconsumer

import (
	"github.com/signalfx/golib/v3/datapoint"
	"github.com/signalfx/signalfx-agent/pkg/monitors"
)

const monitorType = "collectd/kafka_consumer"

const (
	groupJvm = "jvm"
)

var groupSet = map[string]bool{
	groupJvm: true,
}

const (
	gaugeJvmThreadsCount                  = "gauge.jvm.threads.count"
	gaugeKafkaConsumerBytesConsumedRate   = "gauge.kafka.consumer.bytes-consumed-rate"
	gaugeKafkaConsumerFetchRate           = "gauge.kafka.consumer.fetch-rate"
	gaugeKafkaConsumerFetchSizeAvg        = "gauge.kafka.consumer.fetch-size-avg"
	gaugeKafkaConsumerRecordsConsumedRate = "gauge.kafka.consumer.records-consumed-rate"
	gaugeKafkaConsumerRecordsLagMax       = "gauge.kafka.consumer.records-lag-max"
	gaugeLoadedClasses                    = "gauge.loaded_classes"
	invocations                           = "invocations"
	jmxMemoryCommitted                    = "jmx_memory.committed"
	jmxMemoryInit                         = "jmx_memory.init"
	jmxMemoryMax                          = "jmx_memory.max"
	jmxMemoryUsed                         = "jmx_memory.used"
	totalTimeInMsCollectionTime           = "total_time_in_ms.collection_time"
)

var metricSet = map[string]monitors.MetricInfo{
	gaugeJvmThreadsCount:                  {Type: datapoint.Gauge, Group: groupJvm},
	gaugeKafkaConsumerBytesConsumedRate:   {Type: datapoint.Gauge},
	gaugeKafkaConsumerFetchRate:           {Type: datapoint.Gauge},
	gaugeKafkaConsumerFetchSizeAvg:        {Type: datapoint.Gauge},
	gaugeKafkaConsumerRecordsConsumedRate: {Type: datapoint.Gauge},
	gaugeKafkaConsumerRecordsLagMax:       {Type: datapoint.Gauge},
	gaugeLoadedClasses:                    {Type: datapoint.Gauge, Group: groupJvm},
	invocations:                           {Type: datapoint.Counter, Group: groupJvm},
	jmxMemoryCommitted:                    {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryInit:                         {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryMax:                          {Type: datapoint.Gauge, Group: groupJvm},
	jmxMemoryUsed:                         {Type: datapoint.Gauge, Group: groupJvm},
	totalTimeInMsCollectionTime:           {Type: datapoint.Counter, Group: groupJvm},
}

var defaultMetrics = map[string]bool{
	gaugeJvmThreadsCount:                  true,
	gaugeKafkaConsumerBytesConsumedRate:   true,
	gaugeKafkaConsumerFetchRate:           true,
	gaugeKafkaConsumerFetchSizeAvg:        true,
	gaugeKafkaConsumerRecordsConsumedRate: true,
	gaugeKafkaConsumerRecordsLagMax:       true,
	gaugeLoadedClasses:                    true,
	invocations:                           true,
	jmxMemoryCommitted:                    true,
	jmxMemoryInit:                         true,
	jmxMemoryMax:                          true,
	jmxMemoryUsed:                         true,
	totalTimeInMsCollectionTime:           true,
}

var groupMetricsMap = map[string][]string{
	groupJvm: {
		gaugeJvmThreadsCount,
		gaugeLoadedClasses,
		invocations,
		jmxMemoryCommitted,
		jmxMemoryInit,
		jmxMemoryMax,
		jmxMemoryUsed,
		totalTimeInMsCollectionTime,
	},
}

var monitorMetadata = monitors.Metadata{
	MonitorType:     "collectd/kafka_consumer",
	DefaultMetrics:  defaultMetrics,
	Metrics:         metricSet,
	SendUnknown:     true,
	Groups:          groupSet,
	GroupMetricsMap: groupMetricsMap,
	SendAll:         false,
}
