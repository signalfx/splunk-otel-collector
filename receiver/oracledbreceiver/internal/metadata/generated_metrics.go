// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for oracledbreceiver metrics.
type MetricsSettings struct {
	OracledbQueryCPUTime               MetricSettings `mapstructure:"oracledb.query.cpu_time"`
	OracledbQueryElapsedTime           MetricSettings `mapstructure:"oracledb.query.elapsed_time"`
	OracledbQueryExecutions            MetricSettings `mapstructure:"oracledb.query.executions"`
	OracledbQueryLongRunning           MetricSettings `mapstructure:"oracledb.query.long_running"`
	OracledbQueryParseCalls            MetricSettings `mapstructure:"oracledb.query.parse_calls"`
	OracledbQueryPhysicalReadBytes     MetricSettings `mapstructure:"oracledb.query.physical_read_bytes"`
	OracledbQueryPhysicalReadRequests  MetricSettings `mapstructure:"oracledb.query.physical_read_requests"`
	OracledbQueryPhysicalWriteBytes    MetricSettings `mapstructure:"oracledb.query.physical_write_bytes"`
	OracledbQueryPhysicalWriteRequests MetricSettings `mapstructure:"oracledb.query.physical_write_requests"`
	OracledbQueryTotalSharableMem      MetricSettings `mapstructure:"oracledb.query.total_sharable_mem"`
	OracledbSessionCPUUsage            MetricSettings `mapstructure:"oracledb.session.cpu_usage"`
	OracledbSessionEnqueueDeadlocks    MetricSettings `mapstructure:"oracledb.session.enqueue_deadlocks"`
	OracledbSessionExchangeDeadlocks   MetricSettings `mapstructure:"oracledb.session.exchange_deadlocks"`
	OracledbSessionExecuteCount        MetricSettings `mapstructure:"oracledb.session.execute_count"`
	OracledbSessionHardParses          MetricSettings `mapstructure:"oracledb.session.hard_parses"`
	OracledbSessionLogicalReads        MetricSettings `mapstructure:"oracledb.session.logical_reads"`
	OracledbSessionParseCountTotal     MetricSettings `mapstructure:"oracledb.session.parse_count_total"`
	OracledbSessionPgaMemory           MetricSettings `mapstructure:"oracledb.session.pga_memory"`
	OracledbSessionPhysicalReads       MetricSettings `mapstructure:"oracledb.session.physical_reads"`
	OracledbSessionSoftParses          MetricSettings `mapstructure:"oracledb.session.soft_parses"`
	OracledbSessionUserCommits         MetricSettings `mapstructure:"oracledb.session.user_commits"`
	OracledbSessionUserRollbacks       MetricSettings `mapstructure:"oracledb.session.user_rollbacks"`
	OracledbSystemExecuteCount         MetricSettings `mapstructure:"oracledb.system.execute_count"`
	OracledbSystemParseCountTotal      MetricSettings `mapstructure:"oracledb.system.parse_count_total"`
	OracledbSystemResourceLimits       MetricSettings `mapstructure:"oracledb.system.resource_limits"`
	OracledbSystemSessionCount         MetricSettings `mapstructure:"oracledb.system.session_count"`
	OracledbSystemUserCommits          MetricSettings `mapstructure:"oracledb.system.user_commits"`
	OracledbSystemUserRollbacks        MetricSettings `mapstructure:"oracledb.system.user_rollbacks"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		OracledbQueryCPUTime: MetricSettings{
			Enabled: true,
		},
		OracledbQueryElapsedTime: MetricSettings{
			Enabled: true,
		},
		OracledbQueryExecutions: MetricSettings{
			Enabled: true,
		},
		OracledbQueryLongRunning: MetricSettings{
			Enabled: true,
		},
		OracledbQueryParseCalls: MetricSettings{
			Enabled: true,
		},
		OracledbQueryPhysicalReadBytes: MetricSettings{
			Enabled: true,
		},
		OracledbQueryPhysicalReadRequests: MetricSettings{
			Enabled: true,
		},
		OracledbQueryPhysicalWriteBytes: MetricSettings{
			Enabled: true,
		},
		OracledbQueryPhysicalWriteRequests: MetricSettings{
			Enabled: true,
		},
		OracledbQueryTotalSharableMem: MetricSettings{
			Enabled: true,
		},
		OracledbSessionCPUUsage: MetricSettings{
			Enabled: true,
		},
		OracledbSessionEnqueueDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbSessionExchangeDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbSessionExecuteCount: MetricSettings{
			Enabled: true,
		},
		OracledbSessionHardParses: MetricSettings{
			Enabled: true,
		},
		OracledbSessionLogicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbSessionParseCountTotal: MetricSettings{
			Enabled: true,
		},
		OracledbSessionPgaMemory: MetricSettings{
			Enabled: true,
		},
		OracledbSessionPhysicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbSessionSoftParses: MetricSettings{
			Enabled: true,
		},
		OracledbSessionUserCommits: MetricSettings{
			Enabled: true,
		},
		OracledbSessionUserRollbacks: MetricSettings{
			Enabled: true,
		},
		OracledbSystemExecuteCount: MetricSettings{
			Enabled: true,
		},
		OracledbSystemParseCountTotal: MetricSettings{
			Enabled: true,
		},
		OracledbSystemResourceLimits: MetricSettings{
			Enabled: true,
		},
		OracledbSystemSessionCount: MetricSettings{
			Enabled: true,
		},
		OracledbSystemUserCommits: MetricSettings{
			Enabled: true,
		},
		OracledbSystemUserRollbacks: MetricSettings{
			Enabled: true,
		},
	}
}

type metricOracledbQueryCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.cpu_time metric with initial data.
func (m *metricOracledbQueryCPUTime) init() {
	m.data.SetName("oracledb.query.cpu_time")
	m.data.SetDescription("CPU time (in microseconds) used by this cursor for parsing, executing, and fetching.")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryCPUTime(settings MetricSettings) metricOracledbQueryCPUTime {
	m := metricOracledbQueryCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryElapsedTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.elapsed_time metric with initial data.
func (m *metricOracledbQueryElapsedTime) init() {
	m.data.SetName("oracledb.query.elapsed_time")
	m.data.SetDescription("Elapsed time (in microseconds) used by this cursor.")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryElapsedTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryElapsedTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryElapsedTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryElapsedTime(settings MetricSettings) metricOracledbQueryElapsedTime {
	m := metricOracledbQueryElapsedTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryExecutions struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.executions metric with initial data.
func (m *metricOracledbQueryExecutions) init() {
	m.data.SetName("oracledb.query.executions")
	m.data.SetDescription("Number of executions that have taken place on this object.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryExecutions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryExecutions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryExecutions) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryExecutions(settings MetricSettings) metricOracledbQueryExecutions {
	m := metricOracledbQueryExecutions{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryLongRunning struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.long_running metric with initial data.
func (m *metricOracledbQueryLongRunning) init() {
	m.data.SetName("oracledb.query.long_running")
	m.data.SetDescription("Elapsed time (in seconds) of long running queries used by this cursor.")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryLongRunning) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryLongRunning) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryLongRunning) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryLongRunning(settings MetricSettings) metricOracledbQueryLongRunning {
	m := metricOracledbQueryLongRunning{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryParseCalls struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.parse_calls metric with initial data.
func (m *metricOracledbQueryParseCalls) init() {
	m.data.SetName("oracledb.query.parse_calls")
	m.data.SetDescription("Number of parse calls for all cursors with this SQL text and plan.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryParseCalls) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryParseCalls) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryParseCalls) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryParseCalls(settings MetricSettings) metricOracledbQueryParseCalls {
	m := metricOracledbQueryParseCalls{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryPhysicalReadBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.physical_read_bytes metric with initial data.
func (m *metricOracledbQueryPhysicalReadBytes) init() {
	m.data.SetName("oracledb.query.physical_read_bytes")
	m.data.SetDescription("Number of bytes read from disks by the monitored SQL.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryPhysicalReadBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryPhysicalReadBytes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryPhysicalReadBytes) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryPhysicalReadBytes(settings MetricSettings) metricOracledbQueryPhysicalReadBytes {
	m := metricOracledbQueryPhysicalReadBytes{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryPhysicalReadRequests struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.physical_read_requests metric with initial data.
func (m *metricOracledbQueryPhysicalReadRequests) init() {
	m.data.SetName("oracledb.query.physical_read_requests")
	m.data.SetDescription("Number of physical read I/O requests issued by the monitored SQL. The requests may not be disk reads.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryPhysicalReadRequests) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryPhysicalReadRequests) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryPhysicalReadRequests) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryPhysicalReadRequests(settings MetricSettings) metricOracledbQueryPhysicalReadRequests {
	m := metricOracledbQueryPhysicalReadRequests{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryPhysicalWriteBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.physical_write_bytes metric with initial data.
func (m *metricOracledbQueryPhysicalWriteBytes) init() {
	m.data.SetName("oracledb.query.physical_write_bytes")
	m.data.SetDescription("Number of bytes written to disks by the monitored SQL.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryPhysicalWriteBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryPhysicalWriteBytes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryPhysicalWriteBytes) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryPhysicalWriteBytes(settings MetricSettings) metricOracledbQueryPhysicalWriteBytes {
	m := metricOracledbQueryPhysicalWriteBytes{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryPhysicalWriteRequests struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.physical_write_requests metric with initial data.
func (m *metricOracledbQueryPhysicalWriteRequests) init() {
	m.data.SetName("oracledb.query.physical_write_requests")
	m.data.SetDescription("Number of physical write I/O requests issued by the monitored SQL.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryPhysicalWriteRequests) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryPhysicalWriteRequests) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryPhysicalWriteRequests) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryPhysicalWriteRequests(settings MetricSettings) metricOracledbQueryPhysicalWriteRequests {
	m := metricOracledbQueryPhysicalWriteRequests{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbQueryTotalSharableMem struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.query.total_sharable_mem metric with initial data.
func (m *metricOracledbQueryTotalSharableMem) init() {
	m.data.SetName("oracledb.query.total_sharable_mem")
	m.data.SetDescription("Total shared memory (in bytes) occupied by all cursors with this SQL text and plan if they were to be fully loaded in the shared pool (that is, cursor size).")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbQueryTotalSharableMem) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.query.id", oracledbQueryIDAttributeValue)
	dp.Attributes().PutString("oracledb.query.fulltext", oracledbQueryFulltextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbQueryTotalSharableMem) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbQueryTotalSharableMem) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbQueryTotalSharableMem(settings MetricSettings) metricOracledbQueryTotalSharableMem {
	m := metricOracledbQueryTotalSharableMem{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.cpu_usage metric with initial data.
func (m *metricOracledbSessionCPUUsage) init() {
	m.data.SetName("oracledb.session.cpu_usage")
	m.data.SetDescription("CPU usage (%)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionCPUUsage(settings MetricSettings) metricOracledbSessionCPUUsage {
	m := metricOracledbSessionCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionEnqueueDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.enqueue_deadlocks metric with initial data.
func (m *metricOracledbSessionEnqueueDeadlocks) init() {
	m.data.SetName("oracledb.session.enqueue_deadlocks")
	m.data.SetDescription("Total number of deadlocks between table or row locks in different sessions.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionEnqueueDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionEnqueueDeadlocks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionEnqueueDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionEnqueueDeadlocks(settings MetricSettings) metricOracledbSessionEnqueueDeadlocks {
	m := metricOracledbSessionEnqueueDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionExchangeDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.exchange_deadlocks metric with initial data.
func (m *metricOracledbSessionExchangeDeadlocks) init() {
	m.data.SetName("oracledb.session.exchange_deadlocks")
	m.data.SetDescription("Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionExchangeDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionExchangeDeadlocks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionExchangeDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionExchangeDeadlocks(settings MetricSettings) metricOracledbSessionExchangeDeadlocks {
	m := metricOracledbSessionExchangeDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.execute_count metric with initial data.
func (m *metricOracledbSessionExecuteCount) init() {
	m.data.SetName("oracledb.session.execute_count")
	m.data.SetDescription("Total number of calls (user and recursive) that executed SQL statements")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionExecuteCount(settings MetricSettings) metricOracledbSessionExecuteCount {
	m := metricOracledbSessionExecuteCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionHardParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.hard_parses metric with initial data.
func (m *metricOracledbSessionHardParses) init() {
	m.data.SetName("oracledb.session.hard_parses")
	m.data.SetDescription("Number of hard parses")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionHardParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionHardParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionHardParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionHardParses(settings MetricSettings) metricOracledbSessionHardParses {
	m := metricOracledbSessionHardParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.logical_reads metric with initial data.
func (m *metricOracledbSessionLogicalReads) init() {
	m.data.SetName("oracledb.session.logical_reads")
	m.data.SetDescription("Number of logical reads")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionLogicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionLogicalReads(settings MetricSettings) metricOracledbSessionLogicalReads {
	m := metricOracledbSessionLogicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.parse_count_total metric with initial data.
func (m *metricOracledbSessionParseCountTotal) init() {
	m.data.SetName("oracledb.session.parse_count_total")
	m.data.SetDescription("Total number of parse calls (hard, soft, and describe). A soft parse is a check on an object already in the shared pool, to verify that the permissions on the underlying object have not changed.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionParseCountTotal(settings MetricSettings) metricOracledbSessionParseCountTotal {
	m := metricOracledbSessionParseCountTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionPgaMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.pga_memory metric with initial data.
func (m *metricOracledbSessionPgaMemory) init() {
	m.data.SetName("oracledb.session.pga_memory")
	m.data.SetDescription("PGA size at the end of the interval")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionPgaMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionPgaMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionPgaMemory) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionPgaMemory(settings MetricSettings) metricOracledbSessionPgaMemory {
	m := metricOracledbSessionPgaMemory{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.physical_reads metric with initial data.
func (m *metricOracledbSessionPhysicalReads) init() {
	m.data.SetName("oracledb.session.physical_reads")
	m.data.SetDescription("Number of physical reads")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionPhysicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionPhysicalReads(settings MetricSettings) metricOracledbSessionPhysicalReads {
	m := metricOracledbSessionPhysicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionSoftParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.soft_parses metric with initial data.
func (m *metricOracledbSessionSoftParses) init() {
	m.data.SetName("oracledb.session.soft_parses")
	m.data.SetDescription("Number of soft parses")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionSoftParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionSoftParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionSoftParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionSoftParses(settings MetricSettings) metricOracledbSessionSoftParses {
	m := metricOracledbSessionSoftParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.user_commits metric with initial data.
func (m *metricOracledbSessionUserCommits) init() {
	m.data.SetName("oracledb.session.user_commits")
	m.data.SetDescription("Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionUserCommits(settings MetricSettings) metricOracledbSessionUserCommits {
	m := metricOracledbSessionUserCommits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.user_rollbacks metric with initial data.
func (m *metricOracledbSessionUserRollbacks) init() {
	m.data.SetName("oracledb.session.user_rollbacks")
	m.data.SetDescription("Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSessionUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionUserRollbacks(settings MetricSettings) metricOracledbSessionUserRollbacks {
	m := metricOracledbSessionUserRollbacks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.execute_count metric with initial data.
func (m *metricOracledbSystemExecuteCount) init() {
	m.data.SetName("oracledb.system.execute_count")
	m.data.SetDescription("Total number of calls (user and recursive) that executed SQL statements")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSystemExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemExecuteCount(settings MetricSettings) metricOracledbSystemExecuteCount {
	m := metricOracledbSystemExecuteCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.parse_count_total metric with initial data.
func (m *metricOracledbSystemParseCountTotal) init() {
	m.data.SetName("oracledb.system.parse_count_total")
	m.data.SetDescription("Total number of parse calls (hard, soft, and describe). A soft parse is a check on an object already in the shared pool, to verify that the permissions on the underlying object have not changed.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSystemParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemParseCountTotal(settings MetricSettings) metricOracledbSystemParseCountTotal {
	m := metricOracledbSystemParseCountTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemResourceLimits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.resource_limits metric with initial data.
func (m *metricOracledbSystemResourceLimits) init() {
	m.data.SetName("oracledb.system.resource_limits")
	m.data.SetDescription("Designates the current utilization and max, initial and current value of a resource limit across processes, sessions, locks, and more.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSystemResourceLimits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbResourceNameAttributeValue string, oracledbResourceTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.resource.name", oracledbResourceNameAttributeValue)
	dp.Attributes().PutString("oracledb.resource.type", oracledbResourceTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemResourceLimits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemResourceLimits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemResourceLimits(settings MetricSettings) metricOracledbSystemResourceLimits {
	m := metricOracledbSystemResourceLimits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.session_count metric with initial data.
func (m *metricOracledbSystemSessionCount) init() {
	m.data.SetName("oracledb.system.session_count")
	m.data.SetDescription("Count of sessions.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSystemSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, oracledbSessionTypeAttributeValue string, oracledbSessionStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().PutString("oracledb.session.type", oracledbSessionTypeAttributeValue)
	dp.Attributes().PutString("oracledb.session.status", oracledbSessionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemSessionCount(settings MetricSettings) metricOracledbSystemSessionCount {
	m := metricOracledbSystemSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.user_commits metric with initial data.
func (m *metricOracledbSystemUserCommits) init() {
	m.data.SetName("oracledb.system.user_commits")
	m.data.SetDescription("Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSystemUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemUserCommits(settings MetricSettings) metricOracledbSystemUserCommits {
	m := metricOracledbSystemUserCommits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.user_rollbacks metric with initial data.
func (m *metricOracledbSystemUserRollbacks) init() {
	m.data.SetName("oracledb.system.user_rollbacks")
	m.data.SetDescription("Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
}

func (m *metricOracledbSystemUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemUserRollbacks(settings MetricSettings) metricOracledbSystemUserRollbacks {
	m := metricOracledbSystemUserRollbacks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                          int                 // maximum observed number of metrics per resource.
	resourceCapacity                         int                 // maximum observed number of resource attributes.
	metricsBuffer                            pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                component.BuildInfo // contains version information
	metricOracledbQueryCPUTime               metricOracledbQueryCPUTime
	metricOracledbQueryElapsedTime           metricOracledbQueryElapsedTime
	metricOracledbQueryExecutions            metricOracledbQueryExecutions
	metricOracledbQueryLongRunning           metricOracledbQueryLongRunning
	metricOracledbQueryParseCalls            metricOracledbQueryParseCalls
	metricOracledbQueryPhysicalReadBytes     metricOracledbQueryPhysicalReadBytes
	metricOracledbQueryPhysicalReadRequests  metricOracledbQueryPhysicalReadRequests
	metricOracledbQueryPhysicalWriteBytes    metricOracledbQueryPhysicalWriteBytes
	metricOracledbQueryPhysicalWriteRequests metricOracledbQueryPhysicalWriteRequests
	metricOracledbQueryTotalSharableMem      metricOracledbQueryTotalSharableMem
	metricOracledbSessionCPUUsage            metricOracledbSessionCPUUsage
	metricOracledbSessionEnqueueDeadlocks    metricOracledbSessionEnqueueDeadlocks
	metricOracledbSessionExchangeDeadlocks   metricOracledbSessionExchangeDeadlocks
	metricOracledbSessionExecuteCount        metricOracledbSessionExecuteCount
	metricOracledbSessionHardParses          metricOracledbSessionHardParses
	metricOracledbSessionLogicalReads        metricOracledbSessionLogicalReads
	metricOracledbSessionParseCountTotal     metricOracledbSessionParseCountTotal
	metricOracledbSessionPgaMemory           metricOracledbSessionPgaMemory
	metricOracledbSessionPhysicalReads       metricOracledbSessionPhysicalReads
	metricOracledbSessionSoftParses          metricOracledbSessionSoftParses
	metricOracledbSessionUserCommits         metricOracledbSessionUserCommits
	metricOracledbSessionUserRollbacks       metricOracledbSessionUserRollbacks
	metricOracledbSystemExecuteCount         metricOracledbSystemExecuteCount
	metricOracledbSystemParseCountTotal      metricOracledbSystemParseCountTotal
	metricOracledbSystemResourceLimits       metricOracledbSystemResourceLimits
	metricOracledbSystemSessionCount         metricOracledbSystemSessionCount
	metricOracledbSystemUserCommits          metricOracledbSystemUserCommits
	metricOracledbSystemUserRollbacks        metricOracledbSystemUserRollbacks
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                            pmetric.NewMetrics(),
		buildInfo:                                buildInfo,
		metricOracledbQueryCPUTime:               newMetricOracledbQueryCPUTime(settings.OracledbQueryCPUTime),
		metricOracledbQueryElapsedTime:           newMetricOracledbQueryElapsedTime(settings.OracledbQueryElapsedTime),
		metricOracledbQueryExecutions:            newMetricOracledbQueryExecutions(settings.OracledbQueryExecutions),
		metricOracledbQueryLongRunning:           newMetricOracledbQueryLongRunning(settings.OracledbQueryLongRunning),
		metricOracledbQueryParseCalls:            newMetricOracledbQueryParseCalls(settings.OracledbQueryParseCalls),
		metricOracledbQueryPhysicalReadBytes:     newMetricOracledbQueryPhysicalReadBytes(settings.OracledbQueryPhysicalReadBytes),
		metricOracledbQueryPhysicalReadRequests:  newMetricOracledbQueryPhysicalReadRequests(settings.OracledbQueryPhysicalReadRequests),
		metricOracledbQueryPhysicalWriteBytes:    newMetricOracledbQueryPhysicalWriteBytes(settings.OracledbQueryPhysicalWriteBytes),
		metricOracledbQueryPhysicalWriteRequests: newMetricOracledbQueryPhysicalWriteRequests(settings.OracledbQueryPhysicalWriteRequests),
		metricOracledbQueryTotalSharableMem:      newMetricOracledbQueryTotalSharableMem(settings.OracledbQueryTotalSharableMem),
		metricOracledbSessionCPUUsage:            newMetricOracledbSessionCPUUsage(settings.OracledbSessionCPUUsage),
		metricOracledbSessionEnqueueDeadlocks:    newMetricOracledbSessionEnqueueDeadlocks(settings.OracledbSessionEnqueueDeadlocks),
		metricOracledbSessionExchangeDeadlocks:   newMetricOracledbSessionExchangeDeadlocks(settings.OracledbSessionExchangeDeadlocks),
		metricOracledbSessionExecuteCount:        newMetricOracledbSessionExecuteCount(settings.OracledbSessionExecuteCount),
		metricOracledbSessionHardParses:          newMetricOracledbSessionHardParses(settings.OracledbSessionHardParses),
		metricOracledbSessionLogicalReads:        newMetricOracledbSessionLogicalReads(settings.OracledbSessionLogicalReads),
		metricOracledbSessionParseCountTotal:     newMetricOracledbSessionParseCountTotal(settings.OracledbSessionParseCountTotal),
		metricOracledbSessionPgaMemory:           newMetricOracledbSessionPgaMemory(settings.OracledbSessionPgaMemory),
		metricOracledbSessionPhysicalReads:       newMetricOracledbSessionPhysicalReads(settings.OracledbSessionPhysicalReads),
		metricOracledbSessionSoftParses:          newMetricOracledbSessionSoftParses(settings.OracledbSessionSoftParses),
		metricOracledbSessionUserCommits:         newMetricOracledbSessionUserCommits(settings.OracledbSessionUserCommits),
		metricOracledbSessionUserRollbacks:       newMetricOracledbSessionUserRollbacks(settings.OracledbSessionUserRollbacks),
		metricOracledbSystemExecuteCount:         newMetricOracledbSystemExecuteCount(settings.OracledbSystemExecuteCount),
		metricOracledbSystemParseCountTotal:      newMetricOracledbSystemParseCountTotal(settings.OracledbSystemParseCountTotal),
		metricOracledbSystemResourceLimits:       newMetricOracledbSystemResourceLimits(settings.OracledbSystemResourceLimits),
		metricOracledbSystemSessionCount:         newMetricOracledbSystemSessionCount(settings.OracledbSystemSessionCount),
		metricOracledbSystemUserCommits:          newMetricOracledbSystemUserCommits(settings.OracledbSystemUserCommits),
		metricOracledbSystemUserRollbacks:        newMetricOracledbSystemUserRollbacks(settings.OracledbSystemUserRollbacks),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithOracledbInstanceName sets provided value as "oracledb.instance.name" attribute for current resource.
func WithOracledbInstanceName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutString("oracledb.instance.name", val)
	}
}

// WithOracledbSessionID sets provided value as "oracledb.session.id" attribute for current resource.
func WithOracledbSessionID(val int64) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutInt("oracledb.session.id", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).DataType() {
			case pmetric.MetricDataTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricDataTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/oracledbreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricOracledbQueryCPUTime.emit(ils.Metrics())
	mb.metricOracledbQueryElapsedTime.emit(ils.Metrics())
	mb.metricOracledbQueryExecutions.emit(ils.Metrics())
	mb.metricOracledbQueryLongRunning.emit(ils.Metrics())
	mb.metricOracledbQueryParseCalls.emit(ils.Metrics())
	mb.metricOracledbQueryPhysicalReadBytes.emit(ils.Metrics())
	mb.metricOracledbQueryPhysicalReadRequests.emit(ils.Metrics())
	mb.metricOracledbQueryPhysicalWriteBytes.emit(ils.Metrics())
	mb.metricOracledbQueryPhysicalWriteRequests.emit(ils.Metrics())
	mb.metricOracledbQueryTotalSharableMem.emit(ils.Metrics())
	mb.metricOracledbSessionCPUUsage.emit(ils.Metrics())
	mb.metricOracledbSessionEnqueueDeadlocks.emit(ils.Metrics())
	mb.metricOracledbSessionExchangeDeadlocks.emit(ils.Metrics())
	mb.metricOracledbSessionExecuteCount.emit(ils.Metrics())
	mb.metricOracledbSessionHardParses.emit(ils.Metrics())
	mb.metricOracledbSessionLogicalReads.emit(ils.Metrics())
	mb.metricOracledbSessionParseCountTotal.emit(ils.Metrics())
	mb.metricOracledbSessionPgaMemory.emit(ils.Metrics())
	mb.metricOracledbSessionPhysicalReads.emit(ils.Metrics())
	mb.metricOracledbSessionSoftParses.emit(ils.Metrics())
	mb.metricOracledbSessionUserCommits.emit(ils.Metrics())
	mb.metricOracledbSessionUserRollbacks.emit(ils.Metrics())
	mb.metricOracledbSystemExecuteCount.emit(ils.Metrics())
	mb.metricOracledbSystemParseCountTotal.emit(ils.Metrics())
	mb.metricOracledbSystemResourceLimits.emit(ils.Metrics())
	mb.metricOracledbSystemSessionCount.emit(ils.Metrics())
	mb.metricOracledbSystemUserCommits.emit(ils.Metrics())
	mb.metricOracledbSystemUserRollbacks.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordOracledbQueryCPUTimeDataPoint adds a data point to oracledb.query.cpu_time metric.
func (mb *MetricsBuilder) RecordOracledbQueryCPUTimeDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryCPUTime.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryElapsedTimeDataPoint adds a data point to oracledb.query.elapsed_time metric.
func (mb *MetricsBuilder) RecordOracledbQueryElapsedTimeDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryElapsedTime.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryExecutionsDataPoint adds a data point to oracledb.query.executions metric.
func (mb *MetricsBuilder) RecordOracledbQueryExecutionsDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryExecutions.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryLongRunningDataPoint adds a data point to oracledb.query.long_running metric.
func (mb *MetricsBuilder) RecordOracledbQueryLongRunningDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string) {
	mb.metricOracledbQueryLongRunning.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue)
}

// RecordOracledbQueryParseCallsDataPoint adds a data point to oracledb.query.parse_calls metric.
func (mb *MetricsBuilder) RecordOracledbQueryParseCallsDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryParseCalls.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryPhysicalReadBytesDataPoint adds a data point to oracledb.query.physical_read_bytes metric.
func (mb *MetricsBuilder) RecordOracledbQueryPhysicalReadBytesDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryPhysicalReadBytes.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryPhysicalReadRequestsDataPoint adds a data point to oracledb.query.physical_read_requests metric.
func (mb *MetricsBuilder) RecordOracledbQueryPhysicalReadRequestsDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryPhysicalReadRequests.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryPhysicalWriteBytesDataPoint adds a data point to oracledb.query.physical_write_bytes metric.
func (mb *MetricsBuilder) RecordOracledbQueryPhysicalWriteBytesDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryPhysicalWriteBytes.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryPhysicalWriteRequestsDataPoint adds a data point to oracledb.query.physical_write_requests metric.
func (mb *MetricsBuilder) RecordOracledbQueryPhysicalWriteRequestsDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryPhysicalWriteRequests.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbQueryTotalSharableMemDataPoint adds a data point to oracledb.query.total_sharable_mem metric.
func (mb *MetricsBuilder) RecordOracledbQueryTotalSharableMemDataPoint(ts pcommon.Timestamp, val int64, oracledbQueryIDAttributeValue string, oracledbQueryFulltextAttributeValue string) {
	mb.metricOracledbQueryTotalSharableMem.recordDataPoint(mb.startTime, ts, val, oracledbQueryIDAttributeValue, oracledbQueryFulltextAttributeValue)
}

// RecordOracledbSessionCPUUsageDataPoint adds a data point to oracledb.session.cpu_usage metric.
func (mb *MetricsBuilder) RecordOracledbSessionCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricOracledbSessionCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionEnqueueDeadlocksDataPoint adds a data point to oracledb.session.enqueue_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbSessionEnqueueDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionEnqueueDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionExchangeDeadlocksDataPoint adds a data point to oracledb.session.exchange_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbSessionExchangeDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionExchangeDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionExecuteCountDataPoint adds a data point to oracledb.session.execute_count metric.
func (mb *MetricsBuilder) RecordOracledbSessionExecuteCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionExecuteCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionHardParsesDataPoint adds a data point to oracledb.session.hard_parses metric.
func (mb *MetricsBuilder) RecordOracledbSessionHardParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionHardParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionLogicalReadsDataPoint adds a data point to oracledb.session.logical_reads metric.
func (mb *MetricsBuilder) RecordOracledbSessionLogicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionParseCountTotalDataPoint adds a data point to oracledb.session.parse_count_total metric.
func (mb *MetricsBuilder) RecordOracledbSessionParseCountTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionParseCountTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionPgaMemoryDataPoint adds a data point to oracledb.session.pga_memory metric.
func (mb *MetricsBuilder) RecordOracledbSessionPgaMemoryDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionPgaMemory.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionPhysicalReadsDataPoint adds a data point to oracledb.session.physical_reads metric.
func (mb *MetricsBuilder) RecordOracledbSessionPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionPhysicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionSoftParsesDataPoint adds a data point to oracledb.session.soft_parses metric.
func (mb *MetricsBuilder) RecordOracledbSessionSoftParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionSoftParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionUserCommitsDataPoint adds a data point to oracledb.session.user_commits metric.
func (mb *MetricsBuilder) RecordOracledbSessionUserCommitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionUserCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionUserRollbacksDataPoint adds a data point to oracledb.session.user_rollbacks metric.
func (mb *MetricsBuilder) RecordOracledbSessionUserRollbacksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionUserRollbacks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSystemExecuteCountDataPoint adds a data point to oracledb.system.execute_count metric.
func (mb *MetricsBuilder) RecordOracledbSystemExecuteCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSystemExecuteCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSystemParseCountTotalDataPoint adds a data point to oracledb.system.parse_count_total metric.
func (mb *MetricsBuilder) RecordOracledbSystemParseCountTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSystemParseCountTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSystemResourceLimitsDataPoint adds a data point to oracledb.system.resource_limits metric.
func (mb *MetricsBuilder) RecordOracledbSystemResourceLimitsDataPoint(ts pcommon.Timestamp, val int64, oracledbResourceNameAttributeValue string, oracledbResourceTypeAttributeValue string) {
	mb.metricOracledbSystemResourceLimits.recordDataPoint(mb.startTime, ts, val, oracledbResourceNameAttributeValue, oracledbResourceTypeAttributeValue)
}

// RecordOracledbSystemSessionCountDataPoint adds a data point to oracledb.system.session_count metric.
func (mb *MetricsBuilder) RecordOracledbSystemSessionCountDataPoint(ts pcommon.Timestamp, val int64, oracledbSessionTypeAttributeValue string, oracledbSessionStatusAttributeValue string) {
	mb.metricOracledbSystemSessionCount.recordDataPoint(mb.startTime, ts, val, oracledbSessionTypeAttributeValue, oracledbSessionStatusAttributeValue)
}

// RecordOracledbSystemUserCommitsDataPoint adds a data point to oracledb.system.user_commits metric.
func (mb *MetricsBuilder) RecordOracledbSystemUserCommitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSystemUserCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSystemUserRollbacksDataPoint adds a data point to oracledb.system.user_rollbacks metric.
func (mb *MetricsBuilder) RecordOracledbSystemUserRollbacksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSystemUserRollbacks.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
